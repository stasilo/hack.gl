{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/babel-runtime/core-js/array/from.js","node_modules/babel-runtime/core-js/get-iterator.js","node_modules/babel-runtime/core-js/is-iterable.js","node_modules/babel-runtime/core-js/object/assign.js","node_modules/babel-runtime/core-js/object/keys.js","node_modules/babel-runtime/core-js/promise.js","node_modules/babel-runtime/helpers/asyncToGenerator.js","node_modules/babel-runtime/helpers/extends.js","node_modules/babel-runtime/helpers/slicedToArray.js","node_modules/babel-runtime/helpers/toConsumableArray.js","node_modules/babel-runtime/regenerator/index.js","node_modules/core-js/library/fn/array/from.js","node_modules/core-js/library/fn/get-iterator.js","node_modules/core-js/library/fn/is-iterable.js","node_modules/core-js/library/fn/object/assign.js","node_modules/core-js/library/fn/object/keys.js","node_modules/core-js/library/fn/promise.js","node_modules/core-js/library/modules/_a-function.js","node_modules/core-js/library/modules/_add-to-unscopables.js","node_modules/core-js/library/modules/_an-instance.js","node_modules/core-js/library/modules/_an-object.js","node_modules/core-js/library/modules/_array-includes.js","node_modules/core-js/library/modules/_classof.js","node_modules/core-js/library/modules/_cof.js","node_modules/core-js/library/modules/_core.js","node_modules/core-js/library/modules/_create-property.js","node_modules/core-js/library/modules/_ctx.js","node_modules/core-js/library/modules/_defined.js","node_modules/core-js/library/modules/_descriptors.js","node_modules/core-js/library/modules/_dom-create.js","node_modules/core-js/library/modules/_enum-bug-keys.js","node_modules/core-js/library/modules/_export.js","node_modules/core-js/library/modules/_fails.js","node_modules/core-js/library/modules/_for-of.js","node_modules/core-js/library/modules/_global.js","node_modules/core-js/library/modules/_has.js","node_modules/core-js/library/modules/_hide.js","node_modules/core-js/library/modules/_html.js","node_modules/core-js/library/modules/_ie8-dom-define.js","node_modules/core-js/library/modules/_invoke.js","node_modules/core-js/library/modules/_iobject.js","node_modules/core-js/library/modules/_is-array-iter.js","node_modules/core-js/library/modules/_is-object.js","node_modules/core-js/library/modules/_iter-call.js","node_modules/core-js/library/modules/_iter-create.js","node_modules/core-js/library/modules/_iter-define.js","node_modules/core-js/library/modules/_iter-detect.js","node_modules/core-js/library/modules/_iter-step.js","node_modules/core-js/library/modules/_iterators.js","node_modules/core-js/library/modules/_library.js","node_modules/core-js/library/modules/_microtask.js","node_modules/core-js/library/modules/_new-promise-capability.js","node_modules/core-js/library/modules/_object-assign.js","node_modules/core-js/library/modules/_object-create.js","node_modules/core-js/library/modules/_object-dp.js","node_modules/core-js/library/modules/_object-dps.js","node_modules/core-js/library/modules/_object-gops.js","node_modules/core-js/library/modules/_object-gpo.js","node_modules/core-js/library/modules/_object-keys-internal.js","node_modules/core-js/library/modules/_object-keys.js","node_modules/core-js/library/modules/_object-pie.js","node_modules/core-js/library/modules/_object-sap.js","node_modules/core-js/library/modules/_perform.js","node_modules/core-js/library/modules/_promise-resolve.js","node_modules/core-js/library/modules/_property-desc.js","node_modules/core-js/library/modules/_redefine-all.js","node_modules/core-js/library/modules/_redefine.js","node_modules/core-js/library/modules/_set-species.js","node_modules/core-js/library/modules/_set-to-string-tag.js","node_modules/core-js/library/modules/_shared-key.js","node_modules/core-js/library/modules/_shared.js","node_modules/core-js/library/modules/_species-constructor.js","node_modules/core-js/library/modules/_string-at.js","node_modules/core-js/library/modules/_task.js","node_modules/core-js/library/modules/_to-absolute-index.js","node_modules/core-js/library/modules/_to-integer.js","node_modules/core-js/library/modules/_to-iobject.js","node_modules/core-js/library/modules/_to-length.js","node_modules/core-js/library/modules/_to-object.js","node_modules/core-js/library/modules/_to-primitive.js","node_modules/core-js/library/modules/_uid.js","node_modules/core-js/library/modules/_wks.js","node_modules/core-js/library/modules/core.get-iterator-method.js","node_modules/core-js/library/modules/core.get-iterator.js","node_modules/core-js/library/modules/core.is-iterable.js","node_modules/core-js/library/modules/es6.array.from.js","node_modules/core-js/library/modules/es6.array.iterator.js","node_modules/core-js/library/modules/es6.object.assign.js","node_modules/core-js/library/modules/es6.object.keys.js","node_modules/core-js/library/modules/es6.object.to-string.js","node_modules/core-js/library/modules/es6.promise.js","node_modules/core-js/library/modules/es6.string.iterator.js","node_modules/core-js/library/modules/es7.promise.finally.js","node_modules/core-js/library/modules/es7.promise.try.js","node_modules/core-js/library/modules/web.dom.iterable.js","node_modules/regenerator-runtime/runtime-module.js","node_modules/regenerator-runtime/runtime.js","node_modules/whatwg-fetch/fetch.js","src/gl/create-gl-program.js","src/gl/default-uniforms.js","src/gl/init-fbo.js","src/gl/init-pixel-toy.js","src/gl/init-vertex-buffers.js","src/gl/texture-utils.js","src/gl/uniform-utils.js","src/hack-gl.js","src/init/options.js","src/lib/webgl-utils.js","src/shaders/audio-fragment-header.glsl","src/shaders/camera-fragment-header.glsl","src/shaders/fbo-fragment-header.glsl","src/shaders/pixeltoy/default-fragmentshader.glsl","src/shaders/pixeltoy/fragment-header.glsl","src/shaders/pixeltoy/vertex-shader.glsl","src/utils/audio-analyser.js","src/utils/execute-callback-or-array.js","src/utils/frame-count.js","src/utils/get-mouse-position.js","src/utils/iterate-object.js","src/webrtc/init-camera.js"],"names":[],"mappings":"AAAA;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;;ACDA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;kBC7cwB,e;AAAT,SAAS,eAAT,CAAyB,EAAzB,EAA6B,OAA7B,EAAsC,OAAtC,EAA+C;AAC1D;AACA,QAAI,UAAU,GAAG,aAAH,EAAd;AACA,QAAI,CAAC,OAAL,EAAc;AACV,eAAO,IAAP;AACH;;AAED;AACA,QAAI,eAAe,aAAa,EAAb,EAAiB,GAAG,aAApB,EAAmC,OAAnC,CAAnB;AACA,QAAI,iBAAiB,aAAa,EAAb,EAAiB,GAAG,eAApB,EAAqC,OAArC,CAArB;;AAEA;AACA,OAAG,YAAH,CAAgB,OAAhB,EAAyB,YAAzB;AACA,OAAG,YAAH,CA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","file":"hackgl.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/is-iterable\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nvar _promise = require(\"../core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new _promise2.default(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return _promise2.default.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};","\"use strict\";\n\nexports.__esModule = true;\n\nvar _assign = require(\"../core-js/object/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _assign2.default || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};","\"use strict\";\n\nexports.__esModule = true;\n\nvar _isIterable2 = require(\"../core-js/is-iterable\");\n\nvar _isIterable3 = _interopRequireDefault(_isIterable2);\n\nvar _getIterator2 = require(\"../core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if ((0, _isIterable3.default)(Object(arr))) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();","\"use strict\";\n\nexports.__esModule = true;\n\nvar _from = require(\"../core-js/array/from\");\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};","module.exports = require(\"regenerator-runtime\");\n","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.is-iterable');\n","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nrequire('../modules/es7.promise.finally');\nrequire('../modules/es7.promise.try');\nmodule.exports = require('../modules/_core').Promise;\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","module.exports = function () { /* empty */ };\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var core = module.exports = { version: '2.5.1' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","var global = require('./_global');\nvar core = require('./_core');\nvar ctx = require('./_ctx');\nvar hide = require('./_hide');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = true;\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if (Observer) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    var promise = Promise.resolve();\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","exports.f = Object.getOwnPropertySymbols;\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var hide = require('./_hide');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n","module.exports = require('./_hide');\n","'use strict';\nvar global = require('./_global');\nvar core = require('./_core');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","var anObject = require('./_an-object');\nvar get = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    // eslint-disable-next-line no-prototype-builtins\n    || Iterators.hasOwnProperty(classof(O));\n};\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value);\n            if (domain) domain.exit();\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  if (promise._h == 1) return false;\n  var chain = promise._a || promise._c;\n  var i = 0;\n  var reaction;\n  while (chain.length > i) {\n    reaction = chain[i++];\n    if (reaction.fail || !isUnhandled(reaction.promise)) return false;\n  } return true;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","// https://github.com/tc39/proposal-promise-finally\n'use strict';\nvar $export = require('./_export');\nvar core = require('./_core');\nvar global = require('./_global');\nvar speciesConstructor = require('./_species-constructor');\nvar promiseResolve = require('./_promise-resolve');\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n","'use strict';\n// https://github.com/tc39/proposal-promise-try\nvar $export = require('./_export');\nvar newPromiseCapability = require('./_new-promise-capability');\nvar perform = require('./_perform');\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n","require('./es6.array.iterator');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar TO_STRING_TAG = require('./_wks')('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","export default function createGlProgram(gl, vshader, fshader) {\n    // create a program object\n    let program = gl.createProgram();\n    if (!program) {\n        return null;\n    }\n\n    // create shader objects\n    let vertexShader = __loadShader(gl, gl.VERTEX_SHADER, vshader);\n    let fragmentShader = __loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n\n    // attach the shader objects\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n\n    // link the program object\n    gl.linkProgram(program);\n\n    // check the result of linking\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        let error = gl.getProgramInfoLog(program);\n\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n\n        throw `hackGl: Failed to link gl program: ${error}`;\n    }\n\n    return program;\n}\n\nfunction __loadShader(gl, type, source) {\n    // create shader object\n    let shader = gl.createShader(type);\n    if (!shader) {\n        throw 'hackGl: unable to create shader';\n    }\n\n    // set the shader program\n    gl.shaderSource(shader, source);\n    // compile the shader\n    gl.compileShader(shader);\n\n    // check the result of compilation\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n        let error = gl.getShaderInfoLog(shader);\n        gl.deleteShader(shader);\n        throw `hackGl: Failed to compile shader: ${error}`;\n    }\n\n    return shader;\n}\n","import getMousePosition from '../utils/get-mouse-position';\nimport {getFrameCount, updateFrameCount} from '../utils/frame-count';\n\nconst startTime = Date.now();\n\nexport let defaultUniforms = {\n    u_resolution: {\n        type: '2fv',\n        value: [0.0, 0.0]\n    },\n    u_mouse: {\n        type: '2fv',\n        value: [0.0, 0.0],\n        update: () => getMousePosition()\n    },\n    u_time: {\n        type: 'f',\n        value: 0.0,\n        update: () => (Date.now() - startTime) / 1200\n    },\n    u_frame_count: {\n        type: 'i',\n        value: getFrameCount(),\n        update: getFrameCount\n    }\n}\n","import createGlProgram from './create-gl-program';\nimport initVertexBuffers from './init-vertex-buffers';\nimport {initUniforms, updateUniforms, setUniformValue} from './uniform-utils';\nimport {initCameraUniform} from '../webrtc/init-camera';\nimport {initAudioAnalyserUniform} from '../utils/audio-analyser';\nimport {defaultUniforms} from './default-uniforms';\nimport {rebindFboTextures} from './texture-utils';\n\nconst toyFragmentHeader = require('../shaders/pixeltoy/fragment-header.glsl');\nconst audioFragmentHeader = require('../shaders/audio-fragment-header.glsl');\nconst cameraFragmentHeader = require('../shaders/camera-fragment-header.glsl');\nconst fboFragmentHeader = require('../shaders/fbo-fragment-header.glsl');\nconst toyVertexShader = require('../shaders/pixeltoy/vertex-shader.glsl');\nconst defaultFragmentShader = require('../shaders/pixeltoy/default-fragmentshader.glsl');\n\nexport async function initFramebuffer(gl, fboSettings, fboTextureName, options, prevFboUniforms) {\n    let fboShader = `${toyFragmentHeader}\n                     ${(fboSettings.injectWebcamUniform ? cameraFragmentHeader : '')}\n                     ${(fboSettings.audioAnalyser ? audioFragmentHeader : '')}\n                     ${(fboSettings ? fboFragmentHeader : '')}\n                     ${(fboSettings.fragmentShader)}`;\n\n    let fboUniformData = {\n        ...defaultUniforms,\n        ...fboSettings.uniforms,\n        //...prevFboUniforms\n    };\n\n    fboUniformData.u_resolution.value = [\n        options.resolution.width,\n        options.resolution.height\n    ];\n\n    if(fboSettings.injectWebcamUniform){\n        fboUniformData.u_camera = await initCameraUniform();\n    }\n\n    if(fboSettings.audioAnalyser) {\n        fboUniformData.u_audio_data = await initAudioAnalyserUniform(gl, fboSettings);\n    }\n\n    // initialize framebuffer object (FBO)\n    let fbo;\n    try {\n        fbo = _initFramebufferObject(gl, fboSettings, options);\n    } catch(error){\n        console.error(`hackGl: ${error}`);\n        return;\n    }\n\n    fboUniformData[fboTextureName] = {\n        type: 'fbo_t',\n        texture1: fbo.texture1,\n        texture2: fbo.texture2\n    }\n\n    let fboProgram = createGlProgram(gl, toyVertexShader, fboShader);\n    if (!fboProgram) {\n        throw 'hack.Gl: failed to create fbo gl program!';\n    }\n\n    gl.useProgram(fboProgram);\n\n    let fboVertexCount = initVertexBuffers(gl, fboProgram);\n    let fboUniforms = await initUniforms(gl, fboProgram, fboUniformData, fboTextureName);\n\n    let renderToTexture = () => {\n        gl.useProgram(fboProgram);\n\n        rebindFboTextures(gl, fboUniforms);\n        fboUniforms = updateUniforms(gl, fboUniforms);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo); // change the drawing destination to FBO\n\n        // uniform location exists, which means fbo texture accessed in shader => ping pong texture to enable feedback\n        if(fboUniforms[fboTextureName]) {\n            let tmp = fbo.texture2;\n            fbo.texture2 = fbo.texture1;\n            fbo.texture1 = tmp;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbo.texture1, 0);\n\n            gl.activeTexture(gl[`TEXTURE${fboUniforms[fboTextureName].textureUnitNo}`]);\n            gl.bindTexture(gl.TEXTURE_2D, fbo.texture2);\n            gl.uniform1i(fboUniforms[fboTextureName].uniform, fboUniforms[fboTextureName].textureUnitNo);\n        }\n\n        // clear and draw\n        gl.viewport(0, 0, options.resolution.width, options.resolution.height);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, fboVertexCount);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null); // change the drawing destination to color buffer\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        // gl.bindTexture(gl.TEXTURE_2D, fbo.texture2);\n    }\n\n    return {\n        renderToTexture,\n        fboUniform: fboUniforms[fboTextureName],\n        addUniforms: async (uniformData) =>  {\n            gl.useProgram(fboProgram);\n            fboUniforms = {\n                ...fboUniforms,\n                ...(await initUniforms(gl, fboProgram, uniformData, fboTextureName))\n            }\n        }\n    }\n}\n\nfunction _initFramebufferObject(gl, fboSettings, options) {\n    let framebuffer, depthBuffer;\n\n    // define the error handling function\n    let error = () => {\n        if (framebuffer) {\n            gl.deleteFramebuffer(framebuffer);\n        }\n        if (texture1) {\n            gl.deleteTexture(texture1);\n        }\n\n        if (texture2) {\n            gl.deleteTexture(texture2);\n        }\n\n        if (depthBuffer) {\n            gl.deleteRenderbuffer(depthBuffer);\n        }\n\n        return null;\n    }\n\n    // create a frame buffer object (FBO)\n    framebuffer = gl.createFramebuffer();\n    if (!framebuffer) {\n        throw 'failed to create frame buffer object';\n        return error();\n    }\n\n    // create a texture object and set its size and parameters\n    let texture1 = gl.createTexture(); // Create a texture object\n    if (!texture1) {\n        throw 'failed to create texture object';\n        return error();\n    }\n\n    let texture2 = gl.createTexture(); // Create a texture object\n    if (!texture2) {\n        throw 'failed to create texture object';\n        return error();\n    }\n\n    // bind the object to target\n    gl.bindTexture(gl.TEXTURE_2D, texture1);\n    // setup texture to be written to\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, options.resolution.width, options.resolution.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    // note: clamp removes need for w x h being a power of two\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    framebuffer.texture1 = texture1;\n\n    // bind the object to target\n    gl.bindTexture(gl.TEXTURE_2D, texture2);\n    // setup texture2 to be written to\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, options.resolution.width, options.resolution.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    // note: clamp removes need for w x h being a power of two\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    framebuffer.texture2 = texture2;\n\n    // create a renderbuffer object and Set its size and parameters\n    depthBuffer = gl.createRenderbuffer(); // Create a renderbuffer object\n    if (!depthBuffer) {\n        throw 'failed to create renderbuffer object';\n        return error();\n    }\n\n    // bind the object to target\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, options.resolution.width, options.resolution.height);\n\n    // attach the texture and the renderbuffer object to the FBO\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n\n    // check if fbo is configured correctly\n    let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (gl.FRAMEBUFFER_COMPLETE !== e) {\n        throw `frame buffer object is incomplete: ${e.toString()}`;\n        return error();\n    }\n\n    // unbind the buffer object\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return framebuffer;\n}\n","import createGlProgram from './create-gl-program';\nimport initVertexBuffers from './init-vertex-buffers';\nimport {initUniforms, updateUniforms, setUniformValue} from './uniform-utils';\nimport {initFramebuffer} from './init-fbo';\nimport executeCallbackOrArray from '../utils/execute-callback-or-array';\nimport {updateFrameCount} from '../utils/frame-count';\nimport {initCameraUniform} from '../webrtc/init-camera';\nimport {initAudioAnalyserUniform} from '../utils/audio-analyser';\nimport {rebindFboTextures} from './texture-utils';\n\nimport {defaultUniforms} from './default-uniforms';\n\nconst toyFragmentHeader = require('../shaders/pixeltoy/fragment-header.glsl');\nconst audioFragmentHeader = require('../shaders/audio-fragment-header.glsl');\nconst cameraFragmentHeader = require('../shaders/camera-fragment-header.glsl');\nconst fboFragmentHeader = require('../shaders/fbo-fragment-header.glsl');\nconst toyVertexShader = require('../shaders/pixeltoy/vertex-shader.glsl');\nconst defaultFragmentShader = require('../shaders/pixeltoy/default-fragmentshader.glsl');\n\nexport default async function initPixelToy(gl, options) {\n    let uniformData = {\n        ...defaultUniforms,\n        ...options.uniforms\n    };\n\n    let fragmentShader = `${toyFragmentHeader}\n                          ${(options.injectWebcamUniform ? cameraFragmentHeader : '')}\n                          ${(options.audioAnalyser ? audioFragmentHeader : '')}\n                          ${(options.feedbackFbo ? fboFragmentHeader : '')}\n                          ${(options.fragmentShader ? options.fragmentShader : defaultFragmentShader)}`;\n\n    uniformData.u_resolution.value = [options.resolution.width, options.resolution.height];\n\n    if(options.injectWebcamUniform){\n        uniformData.u_camera = await initCameraUniform(options);\n    }\n\n    if(options.audioAnalyser) {\n        uniformData.u_audio_data = await initAudioAnalyserUniform(gl, options);\n    }\n\n    let fbos = [];\n    let fboUniforms = {};\n\n    if(options.feedbackFbo) {\n        let fboCount = 0;\n\n        if(options.feedbackFbo.length) {\n            let fboUniforms = {};\n\n            for(let fboSettings of options.feedbackFbo){\n                let fbo = await initFramebuffer(gl, fboSettings, `u_fbo${fboCount}`, options, fboUniforms);\n\n                if(typeof fbo.fboUniform !== 'undefined') {\n                    uniformData[`u_fbo${fboCount}`] = fbo.fboUniform;\n                    fboUniforms[`u_fbo${fboCount}`] = fbo.fboUniform; // save fbo uniform data\n                }\n\n                fbos.push(fbo);\n                fboCount++;\n            }\n\n            // add all fbo textures to all fbos (=> fbo0 can access fbo3 and fbo3 can access fb01 and so on...)\n            for(let fbo of fbos) {\n                await fbo.addUniforms(fboUniforms);\n            }\n        } else {\n            let fbo = await initFramebuffer(gl, options.feedbackFbo, `u_fbo${fboCount}`, options);\n            uniformData[`u_fbo${fboCount}`] = fbo.fboUniform;\n            fbos.push(fbo);\n        }\n    }\n\n    let program = createGlProgram(gl, toyVertexShader, fragmentShader);\n    if (!program) {\n        throw 'hack.Gl: failed to create main gl program!';\n    }\n\n    gl.useProgram(program);\n    let vertexCount = initVertexBuffers(gl, program, options);\n    let uniforms = await initUniforms(gl, program, uniformData, 'main fragment');\n\n    let _renderFragmentShader = () => {\n        gl.useProgram(program);\n\n        rebindFboTextures(gl, uniforms);\n        uniforms = updateUniforms(gl, uniforms, options);\n\n        gl.viewport(0, 0, options.resolution.width, options.resolution.height); // set a viewport for FBO\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexCount);\n    }\n\n    // main render loop\n    let _render = () => {\n        if(fbos.length) {\n            for(let fbo of fbos) {\n                fbo.renderToTexture();\n            }\n        }\n\n        _renderFragmentShader();\n\n        executeCallbackOrArray(options.onRender);\n        updateFrameCount();\n        requestAnimationFrame(_render);\n    }\n\n    _render();\n}\n","export default function initVertexBuffers(gl, program) {\n    // cover whole canvas with quad\n    let vertices = new Float32Array([\n        -1.0, 1.0,\n        -1.0, -1.0,\n        1.0, 1.0,\n        1.0, -1.0\n    ]);\n\n    let vertexCount = 4; // number of vertices\n\n    // create a buffer object\n    let vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n        throw 'hackGl: failed to create the buffer object';\n    }\n\n    // bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    // write data into the buffer object\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n    let a_position = gl.getAttribLocation(program, 'a_position');\n    if (a_position < 0) {\n        throw 'hackGl: pixeltoy failed to get the storage location of a_position';\n    }\n\n    // assign the buffer object to a_position variable\n    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);\n    // enable the assignment to a_position variable\n    gl.enableVertexAttribArray(a_position);\n\n    return vertexCount;\n}\n","let textureUnitNo = 0;\n\nexport async function loadTextureData(data) {\n    return new Promise((resolve, reject) => {\n        let image = new Image();\n        image.onload = () => resolve(image);\n        image.onerror = (e) => reject(e);\n        image.src = data.url;\n    });\n}\n\nexport function initTexture(gl, data, image) {\n    const maxTextureCount = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    if(textureUnitNo > maxTextureCount) {\n        throw `hackGl: max number of texture units (${maxTextureCount}) exceeded`;\n    }\n\n    let texture = gl.createTexture();\n\n    // activate texture\n    gl.activeTexture(gl[`TEXTURE${textureUnitNo}`]);\n\n    // bind texture object\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // flip axes to xy instead of yx\n    if(typeof data.flipY === 'undefined' || data.flipY != false) {\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n    }\n\n    // set params\n\n    // note: clamp removes need for w x h being a power of two\n    let repeatTypeS = gl.CLAMP_TO_EDGE, repeatTypeT = gl.CLAMP_TO_EDGE;\n    if(_imageDimensionArePowerOf2(image)) {\n        repeatTypeS = gl.REPEAT;\n        repeatTypeT = gl.REPEAT;\n    }\n\n    if(data.wrapS && data.wrapS == 'clamp') {\n        repeatTypeS = gl.CLAMP_TO_EDGE;\n    }\n\n    if(data.wrapT && data.wrapT == 'clamp') {\n        repeatTypeT = gl.CLAMP_TO_EDGE;\n    }\n\n    if(data.wrapS && data.wrapS == 'repeat') {\n        repeatTypeS = gl.REPEAT;\n    }\n\n    if(data.wrapT && data.wrapT == 'repeat') {\n        repeatTypeT = gl.REPEAT;\n    }\n\n    if(data.wrapS && data.wrapS == 'mirrored-repeat') {\n        repeatTypeS = gl.MIRRORED_REPEAT;\n    }\n\n    if(data.wrapT && data.wrapT == 'mirrored-repeat') {\n        repeatTypeT = gl.MIRRORED_REPEAT;\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeatTypeS);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeatTypeT);\n\n    let internalFormat = gl.RGBA; //data.internalFormat ||gl.RGBA;\n    let srcFormat = gl.RGBA; //data.srcFormat ||gl.RGBA;\n    let border = 0;\n\n    // set the texture image\n    if(typeof data.size !== 'undefined') {\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, data.size[0], data.size[1], 0, srcFormat, gl.UNSIGNED_BYTE, image);\n        // gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, data.size[0], data.size[1], 0, srcFormat, gl.FLOAT, data.value);\n    } else {\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, gl.UNSIGNED_BYTE, image);\n    }\n\n    if(data.generateMips) {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n        gl.generateMipmap(gl.TEXTURE_2D);\n    } else {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    }\n\n    // set the texture unit number to the sampler\n    gl.uniform1i(data.uniform, textureUnitNo);\n    data.textureUnitNo = textureUnitNo;\n    data.texture = texture;\n\n    textureUnitNo++;\n    return data;\n}\n\nexport function initFboTexture(gl, data) {\n    gl.activeTexture(gl[`TEXTURE${textureUnitNo}`]);\n    gl.bindTexture(gl.TEXTURE_2D, data.texture2);\n\n    if(data.uniform) {\n        gl.uniform1i(data.uniform, textureUnitNo);\n    }\n\n    data.textureUnitNo = textureUnitNo;\n    textureUnitNo++;\n\n    return data;\n}\n\nexport function bindFboTexture(gl, data) {\n    gl.activeTexture(gl[`TEXTURE${data.textureUnitNo}`]);\n    gl.bindTexture(gl.TEXTURE_2D, data.texture2);\n    gl.uniform1i(data.uniform, data.textureUnitNo);\n    return data;\n}\n\nexport function rebindFboTextures(gl, uniforms) {\n    let fboUniforms = Object.keys(uniforms).reduce((a, uniformName) => (\n        uniformName.startsWith('u_fbo')\n        ? [...a, uniforms[uniformName]]\n        : a\n    ), []);\n\n    fboUniforms.forEach(uniform => {\n        gl.activeTexture(gl[`TEXTURE${uniform.textureUnitNo }`]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture2);\n        gl.uniform1i(uniform.uniform, uniform.textureUnitNo);\n    });\n}\n\nexport function updateTexture(gl, data) {\n    gl.activeTexture(gl[`TEXTURE${data.textureUnitNo}`]);\n    gl.bindTexture(gl.TEXTURE_2D, data.texture);\n\n    let internalFormat = gl.RGBA; //data.internalFormat ||gl.RGBA;\n    let srcFormat = gl.RGBA; //data.srcFormat ||gl.RGBA;\n\n    if(typeof data.size !== 'undefined') {\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, data.size[0], data.size[1], 0, srcFormat, gl.UNSIGNED_BYTE, data.value);\n    } else {\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, gl.UNSIGNED_BYTE, data.value);\n    }\n\n    // gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, gl.UNSIGNED_BYTE, data.value);\n}\n\nfunction _imageDimensionArePowerOf2(image) {\n  return (image.naturalWidth & (image.naturalWidth - 1)) == 0 && (image.naturalHeight & (image.naturalHeight - 1)) == 0;\n}\n","import {initTexture, initFboTexture, bindFboTexture, updateTexture, loadTextureData, rebindFboTextures} from './texture-utils';\nimport iterateObject from '../utils/iterate-object';\n\nexport async function initUniforms(gl, program, uniformData, shaderName) {\n    let result = {};\n\n    for (let [uniformName, data] of iterateObject(uniformData)) {\n        let uniform = gl.getUniformLocation(program, new String(uniformName));\n        if (!uniform) {\n            console.warn(`hackGl: ${shaderName} shader ` +\n                         `failed to get the storage location of \"${uniformName}\" - ignoring variable. ` +\n                         'Perhaps you forgot to use it in your shader?');\n\n            // don't init uniform, but still init texture unit for the fbo rendering\n            if(data.type != 'fbo_t') {\n                continue;\n            }\n        }\n\n        let updatedData = {\n            ...data,\n            uniform\n        };\n\n        // await needed for texture image data loading\n        updatedData = await setUniformValue(gl, updatedData);\n        result[uniformName] = updatedData;\n    }\n\n    return result;\n}\n\nexport function updateUniforms(gl, uniforms, options) {\n    let result = {};\n    for (let [key, data] of iterateObject(uniforms)) {\n        let uniform = result[key] = {...data};\n        if(typeof uniform.update === 'function') {\n            uniform.value = uniform.update(uniform.value);\n            setUniformValue(gl, uniform, true);\n        }\n    }\n\n    return result;\n}\n\nexport async function setUniformValue(gl, data, updating = false) {\n    switch(data.type) {\n        // texture sampler\n        case 't':\n            if(!updating) {\n                let imageData = typeof data.url !== 'undefined' ? await loadTextureData(data) : data.value;\n                data = initTexture(gl, data, imageData);\n            } else if(updating && data.needsUpdate) {\n                updateTexture(gl, data);\n            }\n\n            break;\n\n        // fbo texture sampler\n        case 'fbo_t':\n            if(!updating && !data.textureUnitNo) {\n                data = initFboTexture(gl, data);\n            } else {\n                data = bindFboTexture(gl, data);\n            }\n\n            break\n\n        // integer\n        case 'i':\n            gl.uniform1i(data.uniform, data.value);\n            break;\n\n        // float\n        case 'f':\n            gl.uniform1f(data.uniform, data.value);\n            break;\n\n        // float vec2\n        case '2fv':\n            gl.uniform2fv(data.uniform, data.value);\n            break;\n\n        // float vec3\n        case '3fv':\n            gl.uniform3fv(data.uniform, data.value);\n            break;\n\n        // float vec4\n        case '4fv':\n            gl.uniform4fv(data.uniform, data.value);\n            break;\n\n        default:\n            throw `: ${data.type} uniform not yet implemented!`;\n            break;\n    }\n\n    return data;\n}\n","// require('babel-polyfill');\nimport 'whatwg-fetch';\n\nimport webGlUtils from './lib/webgl-utils';\nimport initPixelToy from './gl/init-pixel-toy';\nimport validateOptions from './init/options';\n\nexport default function hackGl(options) {\n    options = validateOptions(options);\n    if(!options.isValid) {\n        throw `hack.Gl: ${options.errors}`;\n    }\n\n    _setupCanvasResolution(options);\n    let gl = _getWebGlContext(options.canvas);\n\n    // var float_texture_ext = gl.getExtension('OES_texture_float');\n    // console.log(\"Float texture extension: \" + float_texture_ext);\n\n    // specify the color for clearing canvas\n    gl.clearColor(...options.clearColor);\n\n    initPixelToy(gl, options);\n}\n\nfunction _getWebGlContext(canvas, debug = false) {\n    let gl = webGlUtils.setupWebGL(canvas);\n    if (!gl) {\n        throw 'hack.Gl: failed to get the rendering context for webGl';\n    }\n\n    if(debug) {\n        gl = webGlUtils.makeDebugContext(gl);\n    }\n\n    return gl;\n}\n\nfunction _setupCanvasResolution(options) {\n    options.canvas.width = options.resolution.width;\n    options.canvas.height = options.resolution.height;\n}\n","// wow, yeah, this needs work - the boring part\n\nexport default function validateOptions(options) {\n    let validatedOptions = {\n        isValid: true,\n        errors: '',\n        ...options\n    };\n\n    if(typeof options.canvas === 'undefined' || !options.canvas) {\n        validatedOptions.isValid = false;\n        validatedOptions.errors = \"\\nNo canvas element supplied when calling hackGl()\";\n    }\n\n    if(typeof options.clearColor === 'undefined' || !options.clearColor) {\n        validatedOptions.clearColor = [0.0, 0.0, 0.0, 1.0];\n    }\n\n    if(typeof options.resolution === 'undefined' || !options.resolution.width ||!options.resolution.height) {\n        validatedOptions.resolution = {\n            width: window.innerWidth,\n            height: window.innerHeight\n        }\n    }\n\n    if(typeof options.feedbackFbo !== 'undefined') {\n        if(typeof options.feedbackFbo.resolution === 'undefined' ||\n            (!options.feedbackFbo.resolution.width ||!options.feedbackFbo.resolution.height))\n        {\n            validatedOptions.feedbackFbo.resolution = validatedOptions.resolution;\n        }\n    }\n\n    if(typeof options.uniforms === 'undefined') {\n        validatedOptions.uniforms = {};\n    }\n\n    if(typeof options.onRender === 'undefined') {\n        validatedOptions.onRender = [];\n    }\n\n    return validatedOptions;\n}\n","/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\n\nexport default new function() {\n    /**\n     * Provides requestAnimationFrame in a cross browser\n     * way.\n     */\n    if (!window.requestAnimationFrame) {\n      window.requestAnimationFrame = (function() {\n        return window.requestAnimationFrame ||\n               window.webkitRequestAnimationFrame ||\n               window.mozRequestAnimationFrame ||\n               window.oRequestAnimationFrame ||\n               window.msRequestAnimationFrame ||\n               function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n                 window.setTimeout(callback, 1000/60);\n               };\n      })();\n    }\n\n    /** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n     *\n     * Cancels an animation frame request.\n     * Checks for cross-browser support, falls back to clearTimeout.\n     * @param {number}  Animation frame request. */\n    if (!window.cancelAnimationFrame) {\n      window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\n                                     window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||\n                                     window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\n                                     window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\n                                     window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\n                                     window.clearTimeout);\n    }\n\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function(msg) {\n      return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n      return '' +\n        '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n        '<td align=\"center\">' +\n        '<div style=\"display: table-cell; vertical-align: middle;\">' +\n        '<div style=\"\">' + msg + '</div>' +\n        '</div>' +\n        '</td></tr></table>';\n    };\n\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n      'This page requires a browser that supports WebGL.<br/>' +\n      '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n      \"It doesn't appear your computer can support WebGL.<br/>\" +\n      '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @param {Element} canvas. The canvas element to create a\n     *     context from.\n     * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n     *     creation attributes you want to pass in.\n     * @param {function:(msg)} opt_onError An function to call\n     *     if there is an error during creation.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function(canvas, opt_attribs, opt_onError) {\n      function handleCreationError(msg) {\n          var container = document.getElementsByTagName(\"body\")[0];\n        //var container = canvas.parentNode;\n        if (container) {\n          var str = window.WebGLRenderingContext ?\n               OTHER_PROBLEM :\n               GET_A_WEBGL_BROWSER;\n          if (msg) {\n            str += \"<br/><br/>Status: \" + msg;\n          }\n          container.innerHTML = makeFailHTML(str);\n        }\n      };\n\n      opt_onError = opt_onError || handleCreationError;\n\n      if (canvas.addEventListener) {\n        canvas.addEventListener(\"webglcontextcreationerror\", function(event) {\n              opt_onError(event.statusMessage);\n            }, false);\n      }\n      var context = create3DContext(canvas, opt_attribs);\n      if (!context) {\n        if (!window.WebGLRenderingContext) {\n          opt_onError(\"\");\n        } else {\n          opt_onError(\"\");\n        }\n      }\n\n      return context;\n    };\n\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function(canvas, opt_attribs) {\n      var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n      var context = null;\n      for (var ii = 0; ii < names.length; ++ii) {\n        try {\n          context = canvas.getContext(names[ii], opt_attribs);\n        } catch(e) {}\n        if (context) {\n          break;\n        }\n      }\n      return context;\n    }\n\n    return {\n      create3DContext: create3DContext,\n      setupWebGL: setupWebGL\n    };\n}\n","module.exports = \"uniform sampler2D u_audio_data;\\n\\n// https://stackoverflow.com/questions/35799286\\nfloat _hackgl_toLog(float value, float min, float max){\\n    float exp = (value-min) / (max-min);\\n    return min * pow(max/min, exp);\\n}\\n\\n/*\\n * Freq data is stored as unsigned integers/rgba. Since webGl 1 doesn't have texelFetch we have to\\n * access the data with uv coordinates using texture2D.\\n *\\n * Example:\\n * Assume an fft size of 512, which means a bin count of 256 freq data values.\\n * To access freq data at, for example, index 128 in the original array returned from the web audio api, do:\\n * _hackgl_getFreqData(128.0/256.0);\\n */\\n\\nfloat _hackgl_getFreqData(float index) {\\n    return texture2D(u_audio_data, vec2(index, 0.5)).r;\\n}\\n\\nfloat hackgl_getAudioFreqData(float index, float minCrop, float maxCrop) {\\n    // crop bottom and top of range\\n    float xCoord = mix(minCrop, maxCrop, index);\\n\\n    // get freq for current index\\n    float fft = _hackgl_getFreqData(xCoord);\\n    return fft;\\n}\\n\\nfloat hackgl_getAudioFreqData(float index) {\\n    return hackgl_getAudioFreqData(index, 0.3, 0.7);\\n}\\n\\nfloat hackgl_getLogAudioFreqData(float index, float minCrop, float maxCrop) {\\n    //crop bottom and top of range\\n    float xCoord = mix(minCrop, maxCrop, index);\\n    //logarithmic sampling\\n    float xPos = _hackgl_toLog(xCoord, 0.01, 1.0);\\n\\n    // get freq for current index\\n    float fft = _hackgl_getFreqData(xPos);\\n    return fft;\\n}\\n\\nfloat hackgl_getLogAudioFreqData(float index) {\\n    return hackgl_getLogAudioFreqData(index, 0.3, 0.7);\\n}\\n\";\n","module.exports = \"uniform sampler2D u_camera;\\n\";\n","module.exports = \"uniform sampler2D u_fbo0;\\nuniform sampler2D u_fbo1;\\nuniform sampler2D u_fbo2;\\nuniform sampler2D u_fbo3;\\nuniform sampler2D u_fbo4;\\nuniform sampler2D u_fbo5;\\nuniform sampler2D u_fbo6;\\n\";\n","module.exports = \"void main() {\\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n}\\n\";\n","module.exports = \"#ifdef GL_ES\\n    precision mediump float;\\n#endif\\n\\nuniform vec2 u_resolution;\\nuniform vec2 u_mouse;\\nuniform float u_time;\\nuniform int u_frame_count;\\n\";\n","module.exports = \"attribute vec4 a_position;\\n\\nvoid main() {\\n    gl_Position = a_position;\\n}\\n\";\n","const context = new (window.AudioContext || window.webkitAudioContext)();\nvar analyser = null, source = null;\n\nlet audioUniformBase = {\n    type: 't',\n    needsUpdate: true,\n    update: () => getFrequencyData(),\n    wrapS: 'clamp',\n    wrapT: 'clamp'\n}\n\nlet audioUniform = null;\n\nexport async function initAudioAnalyserUniform(gl, options) {\n    if(audioUniform) {\n        return audioUniform;\n    }\n\n    const analyserOptions = options.audioAnalyser;\n\n    analyser = context.createAnalyser();\n    analyser.fftSize = analyserOptions.fftSize || 1024; // 1024 / 2 = 512 data points per sample of sound\n    analyser.smoothingTimeConstant = analyserOptions.smoothing || 0.5; //0.2;\n\n    return fetch(analyserOptions.url)\n        .then(response => response.arrayBuffer())\n        .then(arrayBuffer => context.decodeAudioData(arrayBuffer))\n        .then(audioBuffer => {\n            let source = context.createBufferSource();\n\n            source.buffer = audioBuffer;\n            source.connect(analyser);\n            analyser.connect(context.destination);\n            source.start();\n            source.loop = true;\n\n            audioUniform = {\n                ...audioUniformBase,\n                value: getFrequencyData(),\n                size: [analyser.frequencyBinCount, 1],\n            };\n\n            return audioUniform;\n        }).catch(error => {\n            console.warn(`hack.gl: failed to fetch audio data: `);\n            console.dir(error);\n        });\n}\n\nexport function getFrequencyData() {\n    const size = analyser.frequencyBinCount;\n\n    let dataArray = new Uint8Array(size);\n    let shaderData = new Uint8Array(size * 4);\n\n    // analyser.getByteTimeDomainData(dataArray);\n    analyser.getByteFrequencyData(dataArray);\n\n    dataArray.forEach((val, i) => {\n        shaderData.fill(val, i * 4, (i + 1) * 4);\n    });\n\n    return shaderData;\n}\n","export default function executeCallbackOrArray(callback) {\n    if(Array.isArray(callback)) {\n        callback.forEach(cb => cb());\n    } else if(typeof(callback) === 'function') {\n        callback();\n    } else {\n        throw 'hackGl: illegal callback';\n    }\n}\n","let frameCount = 0;\n\nexport function getFrameCount() {\n    return frameCount;\n}\n\nexport function updateFrameCount() {\n    return ++frameCount;\n}\n\nexport function setFrameCount(val) {\n    frameCount = val;\n    return val;\n}\n","let handler = null;\nlet position = {\n    x: 0,\n    y: 0\n};\n\nexport default function getMousePosition(canvas) {\n    if(!handler) {\n        canvas = typeof canvas === 'undefined' ? document.getElementsByTagName('canvas')[0] : canvas;\n        handler = canvas.onmousemove = e => {\n            position = {\n                x: (e.pageX - canvas.offsetLeft) / canvas.width,\n                y: (e.pageY - canvas.offsetTop) / canvas.height\n            }\n        }\n    }\n\n    return [position.x, position.y];\n}\n","// helper generator to iterate by [key, value] over objects\nexport default function* iterateObject(obj) {\n    for (let key of Object.keys(obj)) {\n        yield [key, obj[key]];\n    }\n}\n","let context = null, canvas = null, streaming = false;\n\nlet cameraUniformBase = {\n    type: 't',\n    needsUpdate: true,\n    value: null,\n    wrapS: 'clamp',\n    wrapT: 'clamp'\n}\n\nexport async function initCameraUniform() {\n    let video;\n\n    try {\n        video = await _initCamera();\n    } catch(error){\n        console.error(error);\n        return;\n    }\n\n    return {\n        ...cameraUniformBase,\n        value: video,\n        update: () => video\n    }\n}\n\n\nasync function _initCamera() {\n    if(streaming) {\n        return document.getElementById('video');\n    }\n\n    let video = _injectVideoElement();\n    let stream;\n\n    try {\n        stream = await _getCameraStream();\n    } catch(error){\n        console.dir(error);\n        throw 'hackGl: Could not load camera stream:';\n    }\n\n    video.srcObject = stream;\n    video.play();\n    streaming = true;\n\n    return new Promise((resolve, reject) => {\n        video.addEventListener('canplay', (e) => resolve(video), false)\n    });\n}\n\nasync function _getCameraStream() {\n    return await navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: {\n            width: {\n                min: 640, ideal: 640, max: 640\n            },\n            height: {\n                min: 480, ideal: 480, max: 480\n            }\n        }\n    });\n}\nfunction _injectVideoElement() {\n    let video = document.createElement('video');\n\n    video.id = 'video';\n    video.style.display = 'none';\n    video.innerHTML = 'Video stream not available.';\n    document.body.insertBefore(video, document.body.childNodes[0]);\n\n    return video;\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9nbC9jcmVhdGUtZ2wtcHJvZ3JhbS5qcyIsInNyYy9nbC9kZWZhdWx0LXVuaWZvcm1zLmpzIiwic3JjL2dsL2luaXQtZmJvLmpzIiwic3JjL2dsL2luaXQtcGl4ZWwtdG95LmpzIiwic3JjL2dsL2luaXQtdmVydGV4LWJ1ZmZlcnMuanMiLCJzcmMvZ2wvdGV4dHVyZS11dGlscy5qcyIsInNyYy9nbC91bmlmb3JtLXV0aWxzLmpzIiwic3JjL2hhY2stZ2wuanMiLCJzcmMvaW5pdC9vcHRpb25zLmpzIiwic3JjL2xpYi93ZWJnbC11dGlscy5qcyIsInNyYy9zaGFkZXJzL2F1ZGlvLWZyYWdtZW50LWhlYWRlci5nbHNsIiwic3JjL3NoYWRlcnMvY2FtZXJhLWZyYWdtZW50LWhlYWRlci5nbHNsIiwic3JjL3NoYWRlcnMvZmJvLWZyYWdtZW50LWhlYWRlci5nbHNsIiwic3JjL3NoYWRlcnMvcGl4ZWx0b3kvZGVmYXVsdC1mcmFnbWVudHNoYWRlci5nbHNsIiwic3JjL3NoYWRlcnMvcGl4ZWx0b3kvZnJhZ21lbnQtaGVhZGVyLmdsc2wiLCJzcmMvc2hhZGVycy9waXhlbHRveS92ZXJ0ZXgtc2hhZGVyLmdsc2wiLCJzcmMvdXRpbHMvYXVkaW8tYW5hbHlzZXIuanMiLCJzcmMvdXRpbHMvZXhlY3V0ZS1jYWxsYmFjay1vci1hcnJheS5qcyIsInNyYy91dGlscy9mcmFtZS1jb3VudC5qcyIsInNyYy91dGlscy9nZXQtbW91c2UtcG9zaXRpb24uanMiLCJzcmMvdXRpbHMvaXRlcmF0ZS1vYmplY3QuanMiLCJzcmMvd2VicnRjL2luaXQtY2FtZXJhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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SGE7QUFJcEIsV0FBTyxPQUphO0FBS3BCLFdBQU87QUFMYSxDQUF4Qjs7QUErREEsU0FBUyxtQkFBVCxHQUErQjtBQUMzQixRQUFJLFFBQVEsU0FBUyxhQUFULENBQXVCLE9BQXZCLENBQVo7O0FBRUEsVUFBTSxFQUFOLEdBQVcsT0FBWDtBQUNBLFVBQU0sS0FBTixDQUFZLE9BQVosR0FBc0IsTUFBdEI7QUFDQSxVQUFNLFNBQU4sR0FBa0IsNkJBQWxCO0FBQ0EsYUFBUyxJQUFULENBQWMsWUFBZCxDQUEyQixLQUEzQixFQUFrQyxTQUFTLElBQVQsQ0FBYyxVQUFkLENBQXlCLENBQXpCLENBQWxDOztBQUVBLFdBQU8sS0FBUDtBQUNIIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzdGVwKFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RlcChcIm5leHRcIik7XG4gICAgfSk7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5rZXlzO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlR2xQcm9ncmFtKGdsLCB2c2hhZGVyLCBmc2hhZGVyKSB7XG4gICAgLy8gY3JlYXRlIGEgcHJvZ3JhbSBvYmplY3RcbiAgICBsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHNoYWRlciBvYmplY3RzXG4gICAgbGV0IHZlcnRleFNoYWRlciA9IF9fbG9hZFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnNoYWRlcik7XG4gICAgbGV0IGZyYWdtZW50U2hhZGVyID0gX19sb2FkU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzaGFkZXIpO1xuXG4gICAgLy8gYXR0YWNoIHRoZSBzaGFkZXIgb2JqZWN0c1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG5cbiAgICAvLyBsaW5rIHRoZSBwcm9ncmFtIG9iamVjdFxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gY2hlY2sgdGhlIHJlc3VsdCBvZiBsaW5raW5nXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBsZXQgZXJyb3IgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcblxuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICAgICAgICB0aHJvdyBgaGFja0dsOiBGYWlsZWQgdG8gbGluayBnbCBwcm9ncmFtOiAke2Vycm9yfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG59XG5cbmZ1bmN0aW9uIF9fbG9hZFNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gICAgLy8gY3JlYXRlIHNoYWRlciBvYmplY3RcbiAgICBsZXQgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICAgIHRocm93ICdoYWNrR2w6IHVuYWJsZSB0byBjcmVhdGUgc2hhZGVyJztcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICAvLyBjb21waWxlIHRoZSBzaGFkZXJcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICAvLyBjaGVjayB0aGUgcmVzdWx0IG9mIGNvbXBpbGF0aW9uXG4gICAgdmFyIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgICAgbGV0IGVycm9yID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgdGhyb3cgYGhhY2tHbDogRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiAke2Vycm9yfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cbiIsImltcG9ydCBnZXRNb3VzZVBvc2l0aW9uIGZyb20gJy4uL3V0aWxzL2dldC1tb3VzZS1wb3NpdGlvbic7XG5pbXBvcnQge2dldEZyYW1lQ291bnQsIHVwZGF0ZUZyYW1lQ291bnR9IGZyb20gJy4uL3V0aWxzL2ZyYW1lLWNvdW50JztcblxuY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuZXhwb3J0IGxldCBkZWZhdWx0VW5pZm9ybXMgPSB7XG4gICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHR5cGU6ICcyZnYnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXVxuICAgIH0sXG4gICAgdV9tb3VzZToge1xuICAgICAgICB0eXBlOiAnMmZ2JyxcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMF0sXG4gICAgICAgIHVwZGF0ZTogKCkgPT4gZ2V0TW91c2VQb3NpdGlvbigpXG4gICAgfSxcbiAgICB1X3RpbWU6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICB1cGRhdGU6ICgpID0+IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEyMDBcbiAgICB9LFxuICAgIHVfZnJhbWVfY291bnQ6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogZ2V0RnJhbWVDb3VudCgpLFxuICAgICAgICB1cGRhdGU6IGdldEZyYW1lQ291bnRcbiAgICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlR2xQcm9ncmFtIGZyb20gJy4vY3JlYXRlLWdsLXByb2dyYW0nO1xuaW1wb3J0IGluaXRWZXJ0ZXhCdWZmZXJzIGZyb20gJy4vaW5pdC12ZXJ0ZXgtYnVmZmVycyc7XG5pbXBvcnQge2luaXRVbmlmb3JtcywgdXBkYXRlVW5pZm9ybXMsIHNldFVuaWZvcm1WYWx1ZX0gZnJvbSAnLi91bmlmb3JtLXV0aWxzJztcbmltcG9ydCB7aW5pdENhbWVyYVVuaWZvcm19IGZyb20gJy4uL3dlYnJ0Yy9pbml0LWNhbWVyYSc7XG5pbXBvcnQge2luaXRBdWRpb0FuYWx5c2VyVW5pZm9ybX0gZnJvbSAnLi4vdXRpbHMvYXVkaW8tYW5hbHlzZXInO1xuaW1wb3J0IHtkZWZhdWx0VW5pZm9ybXN9IGZyb20gJy4vZGVmYXVsdC11bmlmb3Jtcyc7XG5pbXBvcnQge3JlYmluZEZib1RleHR1cmVzfSBmcm9tICcuL3RleHR1cmUtdXRpbHMnO1xuXG5jb25zdCB0b3lGcmFnbWVudEhlYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvcGl4ZWx0b3kvZnJhZ21lbnQtaGVhZGVyLmdsc2wnKTtcbmNvbnN0IGF1ZGlvRnJhZ21lbnRIZWFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2F1ZGlvLWZyYWdtZW50LWhlYWRlci5nbHNsJyk7XG5jb25zdCBjYW1lcmFGcmFnbWVudEhlYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvY2FtZXJhLWZyYWdtZW50LWhlYWRlci5nbHNsJyk7XG5jb25zdCBmYm9GcmFnbWVudEhlYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZmJvLWZyYWdtZW50LWhlYWRlci5nbHNsJyk7XG5jb25zdCB0b3lWZXJ0ZXhTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3BpeGVsdG95L3ZlcnRleC1zaGFkZXIuZ2xzbCcpO1xuY29uc3QgZGVmYXVsdEZyYWdtZW50U2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9waXhlbHRveS9kZWZhdWx0LWZyYWdtZW50c2hhZGVyLmdsc2wnKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRGcmFtZWJ1ZmZlcihnbCwgZmJvU2V0dGluZ3MsIGZib1RleHR1cmVOYW1lLCBvcHRpb25zLCBwcmV2RmJvVW5pZm9ybXMpIHtcbiAgICBsZXQgZmJvU2hhZGVyID0gYCR7dG95RnJhZ21lbnRIZWFkZXJ9XG4gICAgICAgICAgICAgICAgICAgICAkeyhmYm9TZXR0aW5ncy5pbmplY3RXZWJjYW1Vbmlmb3JtID8gY2FtZXJhRnJhZ21lbnRIZWFkZXIgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAkeyhmYm9TZXR0aW5ncy5hdWRpb0FuYWx5c2VyID8gYXVkaW9GcmFnbWVudEhlYWRlciA6ICcnKX1cbiAgICAgICAgICAgICAgICAgICAgICR7KGZib1NldHRpbmdzID8gZmJvRnJhZ21lbnRIZWFkZXIgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAkeyhmYm9TZXR0aW5ncy5mcmFnbWVudFNoYWRlcil9YDtcblxuICAgIGxldCBmYm9Vbmlmb3JtRGF0YSA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFVuaWZvcm1zLFxuICAgICAgICAuLi5mYm9TZXR0aW5ncy51bmlmb3JtcyxcbiAgICAgICAgLy8uLi5wcmV2RmJvVW5pZm9ybXNcbiAgICB9O1xuXG4gICAgZmJvVW5pZm9ybURhdGEudV9yZXNvbHV0aW9uLnZhbHVlID0gW1xuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24ud2lkdGgsXG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcbiAgICBdO1xuXG4gICAgaWYoZmJvU2V0dGluZ3MuaW5qZWN0V2ViY2FtVW5pZm9ybSnCoHtcbiAgICAgICAgZmJvVW5pZm9ybURhdGEudV9jYW1lcmEgPSBhd2FpdCBpbml0Q2FtZXJhVW5pZm9ybSgpO1xuICAgIH1cblxuICAgIGlmKGZib1NldHRpbmdzLmF1ZGlvQW5hbHlzZXIpIHtcbiAgICAgICAgZmJvVW5pZm9ybURhdGEudV9hdWRpb19kYXRhID0gYXdhaXQgaW5pdEF1ZGlvQW5hbHlzZXJVbmlmb3JtKGdsLCBmYm9TZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBmcmFtZWJ1ZmZlciBvYmplY3QgKEZCTylcbiAgICBsZXQgZmJvO1xuICAgIHRyeSB7XG4gICAgICAgIGZibyA9IF9pbml0RnJhbWVidWZmZXJPYmplY3QoZ2wsIGZib1NldHRpbmdzLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoKGVycm9yKcKge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBoYWNrR2w6ICR7ZXJyb3J9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYm9Vbmlmb3JtRGF0YVtmYm9UZXh0dXJlTmFtZV0gPSB7XG4gICAgICAgIHR5cGU6ICdmYm9fdCcsXG4gICAgICAgIHRleHR1cmUxOiBmYm8udGV4dHVyZTEsXG4gICAgICAgIHRleHR1cmUyOiBmYm8udGV4dHVyZTJcbiAgICB9XG5cbiAgICBsZXQgZmJvUHJvZ3JhbSA9IGNyZWF0ZUdsUHJvZ3JhbShnbCwgdG95VmVydGV4U2hhZGVyLCBmYm9TaGFkZXIpO1xuICAgIGlmICghZmJvUHJvZ3JhbSkge1xuICAgICAgICB0aHJvdyAnaGFjay5HbDogZmFpbGVkIHRvIGNyZWF0ZSBmYm8gZ2wgcHJvZ3JhbSEnO1xuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0oZmJvUHJvZ3JhbSk7XG5cbiAgICBsZXQgZmJvVmVydGV4Q291bnQgPSBpbml0VmVydGV4QnVmZmVycyhnbCwgZmJvUHJvZ3JhbSk7XG4gICAgbGV0IGZib1VuaWZvcm1zID0gYXdhaXQgaW5pdFVuaWZvcm1zKGdsLCBmYm9Qcm9ncmFtLCBmYm9Vbmlmb3JtRGF0YSwgZmJvVGV4dHVyZU5hbWUpO1xuXG4gICAgbGV0IHJlbmRlclRvVGV4dHVyZSA9ICgpID0+IHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShmYm9Qcm9ncmFtKTtcblxuICAgICAgICByZWJpbmRGYm9UZXh0dXJlcyhnbCwgZmJvVW5pZm9ybXMpO1xuICAgICAgICBmYm9Vbmlmb3JtcyA9IHVwZGF0ZVVuaWZvcm1zKGdsLCBmYm9Vbmlmb3Jtcyk7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pOyAvLyBjaGFuZ2UgdGhlIGRyYXdpbmcgZGVzdGluYXRpb24gdG8gRkJPXG5cbiAgICAgICAgLy8gdW5pZm9ybSBsb2NhdGlvbiBleGlzdHMsIHdoaWNoIG1lYW5zIGZibyB0ZXh0dXJlIGFjY2Vzc2VkIGluIHNoYWRlciA9PiBwaW5nIHBvbmcgdGV4dHVyZSB0byBlbmFibGUgZmVlZGJhY2tcbiAgICAgICAgaWYoZmJvVW5pZm9ybXNbZmJvVGV4dHVyZU5hbWVdKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gZmJvLnRleHR1cmUyO1xuICAgICAgICAgICAgZmJvLnRleHR1cmUyID0gZmJvLnRleHR1cmUxO1xuICAgICAgICAgICAgZmJvLnRleHR1cmUxID0gdG1wO1xuXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGZiby50ZXh0dXJlMSwgMCk7XG5cbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke2Zib1VuaWZvcm1zW2Zib1RleHR1cmVOYW1lXS50ZXh0dXJlVW5pdE5vfWBdKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGZiby50ZXh0dXJlMik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoZmJvVW5pZm9ybXNbZmJvVGV4dHVyZU5hbWVdLnVuaWZvcm0sIGZib1VuaWZvcm1zW2Zib1RleHR1cmVOYW1lXS50ZXh0dXJlVW5pdE5vKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGFuZCBkcmF3XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCwgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgZmJvVmVydGV4Q291bnQpO1xuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IC8vIGNoYW5nZSB0aGUgZHJhd2luZyBkZXN0aW5hdGlvbiB0byBjb2xvciBidWZmZXJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIC8vIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGZiby50ZXh0dXJlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyVG9UZXh0dXJlLFxuICAgICAgICBmYm9Vbmlmb3JtOiBmYm9Vbmlmb3Jtc1tmYm9UZXh0dXJlTmFtZV0sXG4gICAgICAgIGFkZFVuaWZvcm1zOiBhc3luYyAodW5pZm9ybURhdGEpID0+ICB7XG4gICAgICAgICAgICBnbC51c2VQcm9ncmFtKGZib1Byb2dyYW0pO1xuICAgICAgICAgICAgZmJvVW5pZm9ybXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmJvVW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IGluaXRVbmlmb3JtcyhnbCwgZmJvUHJvZ3JhbSwgdW5pZm9ybURhdGEsIGZib1RleHR1cmVOYW1lKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gX2luaXRGcmFtZWJ1ZmZlck9iamVjdChnbCwgZmJvU2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgZnJhbWVidWZmZXIsIGRlcHRoQnVmZmVyO1xuXG4gICAgLy8gZGVmaW5lIHRoZSBlcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgIGxldCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHR1cmUxKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0dXJlMikge1xuICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihkZXB0aEJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBmcmFtZSBidWZmZXIgb2JqZWN0IChGQk8pXG4gICAgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgICAgdGhyb3cgJ2ZhaWxlZCB0byBjcmVhdGUgZnJhbWUgYnVmZmVyIG9iamVjdCc7XG4gICAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIHRleHR1cmUgb2JqZWN0IGFuZCBzZXQgaXRzIHNpemUgYW5kIHBhcmFtZXRlcnNcbiAgICBsZXQgdGV4dHVyZTEgPSBnbC5jcmVhdGVUZXh0dXJlKCk7IC8vIENyZWF0ZSBhIHRleHR1cmUgb2JqZWN0XG4gICAgaWYgKCF0ZXh0dXJlMSkge1xuICAgICAgICB0aHJvdyAnZmFpbGVkIHRvIGNyZWF0ZSB0ZXh0dXJlIG9iamVjdCc7XG4gICAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cblxuICAgIGxldCB0ZXh0dXJlMiA9IGdsLmNyZWF0ZVRleHR1cmUoKTsgLy8gQ3JlYXRlIGEgdGV4dHVyZSBvYmplY3RcbiAgICBpZiAoIXRleHR1cmUyKSB7XG4gICAgICAgIHRocm93ICdmYWlsZWQgdG8gY3JlYXRlIHRleHR1cmUgb2JqZWN0JztcbiAgICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gYmluZCB0aGUgb2JqZWN0IHRvIHRhcmdldFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUxKTtcbiAgICAvLyBzZXR1cCB0ZXh0dXJlIHRvIGJlIHdyaXR0ZW4gdG9cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCwgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAvLyBub3RlOiBjbGFtcCByZW1vdmVzIG5lZWQgZm9yIHcgeCBoIGJlaW5nIGEgcG93ZXIgb2YgdHdvXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICBmcmFtZWJ1ZmZlci50ZXh0dXJlMSA9IHRleHR1cmUxO1xuXG4gICAgLy8gYmluZCB0aGUgb2JqZWN0IHRvIHRhcmdldFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUyKTtcbiAgICAvLyBzZXR1cCB0ZXh0dXJlMiB0byBiZSB3cml0dGVuIHRvXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBvcHRpb25zLnJlc29sdXRpb24ud2lkdGgsIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgLy8gbm90ZTogY2xhbXAgcmVtb3ZlcyBuZWVkIGZvciB3IHggaCBiZWluZyBhIHBvd2VyIG9mIHR3b1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgZnJhbWVidWZmZXIudGV4dHVyZTIgPSB0ZXh0dXJlMjtcblxuICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmJ1ZmZlciBvYmplY3QgYW5kIFNldCBpdHMgc2l6ZSBhbmQgcGFyYW1ldGVyc1xuICAgIGRlcHRoQnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7IC8vIENyZWF0ZSBhIHJlbmRlcmJ1ZmZlciBvYmplY3RcbiAgICBpZiAoIWRlcHRoQnVmZmVyKSB7XG4gICAgICAgIHRocm93ICdmYWlsZWQgdG8gY3JlYXRlIHJlbmRlcmJ1ZmZlciBvYmplY3QnO1xuICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBiaW5kIHRoZSBvYmplY3QgdG8gdGFyZ2V0XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGRlcHRoQnVmZmVyKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCwgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCk7XG5cbiAgICAvLyBhdHRhY2ggdGhlIHRleHR1cmUgYW5kIHRoZSByZW5kZXJidWZmZXIgb2JqZWN0IHRvIHRoZSBGQk9cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUxLCAwKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBkZXB0aEJ1ZmZlcik7XG5cbiAgICAvLyBjaGVjayBpZiBmYm8gaXMgY29uZmlndXJlZCBjb3JyZWN0bHlcbiAgICBsZXQgZSA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgIGlmIChnbC5GUkFNRUJVRkZFUl9DT01QTEVURSAhPT0gZSkge1xuICAgICAgICB0aHJvdyBgZnJhbWUgYnVmZmVyIG9iamVjdCBpcyBpbmNvbXBsZXRlOiAke2UudG9TdHJpbmcoKX1gO1xuICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyB1bmJpbmQgdGhlIGJ1ZmZlciBvYmplY3RcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgIHJldHVybiBmcmFtZWJ1ZmZlcjtcbn1cbiIsImltcG9ydCBjcmVhdGVHbFByb2dyYW0gZnJvbSAnLi9jcmVhdGUtZ2wtcHJvZ3JhbSc7XG5pbXBvcnQgaW5pdFZlcnRleEJ1ZmZlcnMgZnJvbSAnLi9pbml0LXZlcnRleC1idWZmZXJzJztcbmltcG9ydCB7aW5pdFVuaWZvcm1zLCB1cGRhdGVVbmlmb3Jtcywgc2V0VW5pZm9ybVZhbHVlfSBmcm9tICcuL3VuaWZvcm0tdXRpbHMnO1xuaW1wb3J0IHtpbml0RnJhbWVidWZmZXJ9IGZyb20gJy4vaW5pdC1mYm8nO1xuaW1wb3J0IGV4ZWN1dGVDYWxsYmFja09yQXJyYXkgZnJvbSAnLi4vdXRpbHMvZXhlY3V0ZS1jYWxsYmFjay1vci1hcnJheSc7XG5pbXBvcnQge3VwZGF0ZUZyYW1lQ291bnR9IGZyb20gJy4uL3V0aWxzL2ZyYW1lLWNvdW50JztcbmltcG9ydCB7aW5pdENhbWVyYVVuaWZvcm19IGZyb20gJy4uL3dlYnJ0Yy9pbml0LWNhbWVyYSc7XG5pbXBvcnQge2luaXRBdWRpb0FuYWx5c2VyVW5pZm9ybX0gZnJvbSAnLi4vdXRpbHMvYXVkaW8tYW5hbHlzZXInO1xuaW1wb3J0IHtyZWJpbmRGYm9UZXh0dXJlc30gZnJvbSAnLi90ZXh0dXJlLXV0aWxzJztcblxuaW1wb3J0IHtkZWZhdWx0VW5pZm9ybXN9IGZyb20gJy4vZGVmYXVsdC11bmlmb3Jtcyc7XG5cbmNvbnN0IHRveUZyYWdtZW50SGVhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9waXhlbHRveS9mcmFnbWVudC1oZWFkZXIuZ2xzbCcpO1xuY29uc3QgYXVkaW9GcmFnbWVudEhlYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYXVkaW8tZnJhZ21lbnQtaGVhZGVyLmdsc2wnKTtcbmNvbnN0IGNhbWVyYUZyYWdtZW50SGVhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9jYW1lcmEtZnJhZ21lbnQtaGVhZGVyLmdsc2wnKTtcbmNvbnN0IGZib0ZyYWdtZW50SGVhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9mYm8tZnJhZ21lbnQtaGVhZGVyLmdsc2wnKTtcbmNvbnN0IHRveVZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvcGl4ZWx0b3kvdmVydGV4LXNoYWRlci5nbHNsJyk7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3BpeGVsdG95L2RlZmF1bHQtZnJhZ21lbnRzaGFkZXIuZ2xzbCcpO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBpbml0UGl4ZWxUb3koZ2wsIG9wdGlvbnMpIHtcbiAgICBsZXQgdW5pZm9ybURhdGEgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRVbmlmb3JtcyxcbiAgICAgICAgLi4ub3B0aW9ucy51bmlmb3Jtc1xuICAgIH07XG5cbiAgICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBgJHt0b3lGcmFnbWVudEhlYWRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHsob3B0aW9ucy5pbmplY3RXZWJjYW1Vbmlmb3JtID8gY2FtZXJhRnJhZ21lbnRIZWFkZXIgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICR7KG9wdGlvbnMuYXVkaW9BbmFseXNlciA/IGF1ZGlvRnJhZ21lbnRIZWFkZXIgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICR7KG9wdGlvbnMuZmVlZGJhY2tGYm8gPyBmYm9GcmFnbWVudEhlYWRlciA6ICcnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHsob3B0aW9ucy5mcmFnbWVudFNoYWRlciA/IG9wdGlvbnMuZnJhZ21lbnRTaGFkZXIgOiBkZWZhdWx0RnJhZ21lbnRTaGFkZXIpfWA7XG5cbiAgICB1bmlmb3JtRGF0YS51X3Jlc29sdXRpb24udmFsdWUgPSBbb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoLCBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XTtcblxuICAgIGlmKG9wdGlvbnMuaW5qZWN0V2ViY2FtVW5pZm9ybSnCoHtcbiAgICAgICAgdW5pZm9ybURhdGEudV9jYW1lcmEgPSBhd2FpdCBpbml0Q2FtZXJhVW5pZm9ybShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLmF1ZGlvQW5hbHlzZXIpIHtcbiAgICAgICAgdW5pZm9ybURhdGEudV9hdWRpb19kYXRhID0gYXdhaXQgaW5pdEF1ZGlvQW5hbHlzZXJVbmlmb3JtKGdsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBsZXQgZmJvcyA9IFtdO1xuICAgIGxldCBmYm9Vbmlmb3JtcyA9IHt9O1xuXG4gICAgaWYob3B0aW9ucy5mZWVkYmFja0Zibykge1xuICAgICAgICBsZXQgZmJvQ291bnQgPSAwO1xuXG4gICAgICAgIGlmKG9wdGlvbnMuZmVlZGJhY2tGYm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmJvVW5pZm9ybXMgPSB7fTtcblxuICAgICAgICAgICAgZm9yKGxldCBmYm9TZXR0aW5ncyBvZiBvcHRpb25zLmZlZWRiYWNrRmJvKcKge1xuICAgICAgICAgICAgICAgIGxldCBmYm8gPSBhd2FpdCBpbml0RnJhbWVidWZmZXIoZ2wsIGZib1NldHRpbmdzLCBgdV9mYm8ke2Zib0NvdW50fWAsIG9wdGlvbnMsIGZib1VuaWZvcm1zKTtcblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBmYm8uZmJvVW5pZm9ybSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybURhdGFbYHVfZmJvJHtmYm9Db3VudH1gXSA9IGZiby5mYm9Vbmlmb3JtO1xuICAgICAgICAgICAgICAgICAgICBmYm9Vbmlmb3Jtc1tgdV9mYm8ke2Zib0NvdW50fWBdID0gZmJvLmZib1VuaWZvcm07IC8vIHNhdmUgZmJvIHVuaWZvcm0gZGF0YVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZib3MucHVzaChmYm8pO1xuICAgICAgICAgICAgICAgIGZib0NvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbGwgZmJvIHRleHR1cmVzIHRvIGFsbCBmYm9zICg9PiBmYm8wIGNhbiBhY2Nlc3MgZmJvMyBhbmQgZmJvMyBjYW4gYWNjZXNzIGZiMDEgYW5kIHNvIG9uLi4uKVxuICAgICAgICAgICAgZm9yKGxldCBmYm8gb2YgZmJvcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZiby5hZGRVbmlmb3JtcyhmYm9Vbmlmb3Jtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmJvID0gYXdhaXQgaW5pdEZyYW1lYnVmZmVyKGdsLCBvcHRpb25zLmZlZWRiYWNrRmJvLCBgdV9mYm8ke2Zib0NvdW50fWAsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdW5pZm9ybURhdGFbYHVfZmJvJHtmYm9Db3VudH1gXSA9IGZiby5mYm9Vbmlmb3JtO1xuICAgICAgICAgICAgZmJvcy5wdXNoKGZibyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcHJvZ3JhbSA9IGNyZWF0ZUdsUHJvZ3JhbShnbCwgdG95VmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFwcm9ncmFtKSB7XG4gICAgICAgIHRocm93ICdoYWNrLkdsOiBmYWlsZWQgdG8gY3JlYXRlIG1haW4gZ2wgcHJvZ3JhbSEnO1xuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgbGV0IHZlcnRleENvdW50ID0gaW5pdFZlcnRleEJ1ZmZlcnMoZ2wsIHByb2dyYW0sIG9wdGlvbnMpO1xuICAgIGxldCB1bmlmb3JtcyA9IGF3YWl0IGluaXRVbmlmb3JtcyhnbCwgcHJvZ3JhbSwgdW5pZm9ybURhdGEsICdtYWluIGZyYWdtZW50Jyk7XG5cbiAgICBsZXQgX3JlbmRlckZyYWdtZW50U2hhZGVyID0gKCkgPT4ge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAgIHJlYmluZEZib1RleHR1cmVzKGdsLCB1bmlmb3Jtcyk7XG4gICAgICAgIHVuaWZvcm1zID0gdXBkYXRlVW5pZm9ybXMoZ2wsIHVuaWZvcm1zLCBvcHRpb25zKTtcblxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBvcHRpb25zLnJlc29sdXRpb24ud2lkdGgsIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQpOyAvLyBzZXQgYSB2aWV3cG9ydCBmb3IgRkJPXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB2ZXJ0ZXhDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gbWFpbiByZW5kZXIgbG9vcFxuICAgIGxldCBfcmVuZGVyID0gKCkgPT4ge1xuICAgICAgICBpZihmYm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yKGxldCBmYm8gb2YgZmJvcykge1xuICAgICAgICAgICAgICAgIGZiby5yZW5kZXJUb1RleHR1cmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW5kZXJGcmFnbWVudFNoYWRlcigpO1xuXG4gICAgICAgIGV4ZWN1dGVDYWxsYmFja09yQXJyYXkob3B0aW9ucy5vblJlbmRlcik7XG4gICAgICAgIHVwZGF0ZUZyYW1lQ291bnQoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9yZW5kZXIpO1xuICAgIH1cblxuICAgIF9yZW5kZXIoKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRWZXJ0ZXhCdWZmZXJzKGdsLCBwcm9ncmFtKSB7XG4gICAgLy8gY292ZXIgd2hvbGUgY2FudmFzIHdpdGggcXVhZFxuICAgIGxldCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAtMS4wLCAxLjAsXG4gICAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgIDEuMCwgMS4wLFxuICAgICAgICAxLjAsIC0xLjBcbiAgICBdKTtcblxuICAgIGxldCB2ZXJ0ZXhDb3VudCA9IDQ7IC8vIG51bWJlciBvZiB2ZXJ0aWNlc1xuXG4gICAgLy8gY3JlYXRlIGEgYnVmZmVyIG9iamVjdFxuICAgIGxldCB2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIXZlcnRleEJ1ZmZlcikge1xuICAgICAgICB0aHJvdyAnaGFja0dsOiBmYWlsZWQgdG8gY3JlYXRlIHRoZSBidWZmZXIgb2JqZWN0JztcbiAgICB9XG5cbiAgICAvLyBiaW5kIHRoZSBidWZmZXIgb2JqZWN0IHRvIHRhcmdldFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpO1xuICAgIC8vIHdyaXRlIGRhdGEgaW50byB0aGUgYnVmZmVyIG9iamVjdFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgbGV0IGFfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgIGlmIChhX3Bvc2l0aW9uIDwgMCkge1xuICAgICAgICB0aHJvdyAnaGFja0dsOiBwaXhlbHRveSBmYWlsZWQgdG8gZ2V0IHRoZSBzdG9yYWdlIGxvY2F0aW9uIG9mIGFfcG9zaXRpb24nO1xuICAgIH1cblxuICAgIC8vIGFzc2lnbiB0aGUgYnVmZmVyIG9iamVjdCB0byBhX3Bvc2l0aW9uIHZhcmlhYmxlXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhX3Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIC8vIGVuYWJsZSB0aGUgYXNzaWdubWVudCB0byBhX3Bvc2l0aW9uIHZhcmlhYmxlXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9wb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdmVydGV4Q291bnQ7XG59XG4iLCJsZXQgdGV4dHVyZVVuaXRObyA9IDA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkVGV4dHVyZURhdGEoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IChlKSA9PiByZWplY3QoZSk7XG4gICAgICAgIGltYWdlLnNyYyA9IGRhdGEudXJsO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRleHR1cmUoZ2wsIGRhdGEsIGltYWdlKSB7XG4gICAgY29uc3QgbWF4VGV4dHVyZUNvdW50ID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICBpZih0ZXh0dXJlVW5pdE5vID4gbWF4VGV4dHVyZUNvdW50KSB7XG4gICAgICAgIHRocm93IGBoYWNrR2w6IG1heCBudW1iZXIgb2YgdGV4dHVyZSB1bml0cyAoJHttYXhUZXh0dXJlQ291bnR9KSBleGNlZWRlZGA7XG4gICAgfVxuXG4gICAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAvLyBhY3RpdmF0ZSB0ZXh0dXJlXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7dGV4dHVyZVVuaXROb31gXSk7XG5cbiAgICAvLyBiaW5kIHRleHR1cmUgb2JqZWN0XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cbiAgICAvLyBmbGlwIGF4ZXMgdG8geHkgaW5zdGVhZCBvZiB5eFxuICAgIGlmKHR5cGVvZiBkYXRhLmZsaXBZID09PSAndW5kZWZpbmVkJyB8fCBkYXRhLmZsaXBZICE9IGZhbHNlKSB7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIDEpO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJhbXNcblxuICAgIC8vIG5vdGU6IGNsYW1wIHJlbW92ZXMgbmVlZCBmb3IgdyB4IGggYmVpbmcgYSBwb3dlciBvZiB0d29cbiAgICBsZXQgcmVwZWF0VHlwZVMgPSBnbC5DTEFNUF9UT19FREdFLCByZXBlYXRUeXBlVCA9IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgaWYoX2ltYWdlRGltZW5zaW9uQXJlUG93ZXJPZjIoaW1hZ2UpKSB7XG4gICAgICAgIHJlcGVhdFR5cGVTID0gZ2wuUkVQRUFUO1xuICAgICAgICByZXBlYXRUeXBlVCA9IGdsLlJFUEVBVDtcbiAgICB9XG5cbiAgICBpZihkYXRhLndyYXBTICYmIGRhdGEud3JhcFMgPT0gJ2NsYW1wJykge1xuICAgICAgICByZXBlYXRUeXBlUyA9IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgfVxuXG4gICAgaWYoZGF0YS53cmFwVCAmJiBkYXRhLndyYXBUID09ICdjbGFtcCcpIHtcbiAgICAgICAgcmVwZWF0VHlwZVQgPSBnbC5DTEFNUF9UT19FREdFO1xuICAgIH1cblxuICAgIGlmKGRhdGEud3JhcFMgJiYgZGF0YS53cmFwUyA9PSAncmVwZWF0Jykge1xuICAgICAgICByZXBlYXRUeXBlUyA9IGdsLlJFUEVBVDtcbiAgICB9XG5cbiAgICBpZihkYXRhLndyYXBUICYmIGRhdGEud3JhcFQgPT0gJ3JlcGVhdCcpIHtcbiAgICAgICAgcmVwZWF0VHlwZVQgPSBnbC5SRVBFQVQ7XG4gICAgfVxuXG4gICAgaWYoZGF0YS53cmFwUyAmJiBkYXRhLndyYXBTID09ICdtaXJyb3JlZC1yZXBlYXQnKSB7XG4gICAgICAgIHJlcGVhdFR5cGVTID0gZ2wuTUlSUk9SRURfUkVQRUFUO1xuICAgIH1cblxuICAgIGlmKGRhdGEud3JhcFQgJiYgZGF0YS53cmFwVCA9PSAnbWlycm9yZWQtcmVwZWF0Jykge1xuICAgICAgICByZXBlYXRUeXBlVCA9IGdsLk1JUlJPUkVEX1JFUEVBVDtcbiAgICB9XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCByZXBlYXRUeXBlUyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgcmVwZWF0VHlwZVQpO1xuXG4gICAgbGV0IGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTsgLy9kYXRhLmludGVybmFsRm9ybWF0IHx8wqBnbC5SR0JBO1xuICAgIGxldCBzcmNGb3JtYXQgPSBnbC5SR0JBOyAvL2RhdGEuc3JjRm9ybWF0IHx8wqBnbC5SR0JBO1xuICAgIGxldCBib3JkZXIgPSAwO1xuXG4gICAgLy8gc2V0IHRoZSB0ZXh0dXJlIGltYWdlXG4gICAgaWYodHlwZW9mIGRhdGEuc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgZGF0YS5zaXplWzBdLCBkYXRhLnNpemVbMV0sIDAsIHNyY0Zvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgICAgICAvLyBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBkYXRhLnNpemVbMF0sIGRhdGEuc2l6ZVsxXSwgMCwgc3JjRm9ybWF0LCBnbC5GTE9BVCwgZGF0YS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgc3JjRm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgfVxuXG4gICAgaWYoZGF0YS5nZW5lcmF0ZU1pcHMpIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUik7XG4gICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgdGV4dHVyZSB1bml0IG51bWJlciB0byB0aGUgc2FtcGxlclxuICAgIGdsLnVuaWZvcm0xaShkYXRhLnVuaWZvcm0sIHRleHR1cmVVbml0Tm8pO1xuICAgIGRhdGEudGV4dHVyZVVuaXRObyA9IHRleHR1cmVVbml0Tm87XG4gICAgZGF0YS50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgIHRleHR1cmVVbml0Tm8rKztcbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRGYm9UZXh0dXJlKGdsLCBkYXRhKSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7dGV4dHVyZVVuaXROb31gXSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZGF0YS50ZXh0dXJlMik7XG5cbiAgICBpZihkYXRhLnVuaWZvcm0pIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGRhdGEudW5pZm9ybSwgdGV4dHVyZVVuaXRObyk7XG4gICAgfVxuXG4gICAgZGF0YS50ZXh0dXJlVW5pdE5vID0gdGV4dHVyZVVuaXRObztcbiAgICB0ZXh0dXJlVW5pdE5vKys7XG5cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRGYm9UZXh0dXJlKGdsLCBkYXRhKSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7ZGF0YS50ZXh0dXJlVW5pdE5vfWBdKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkYXRhLnRleHR1cmUyKTtcbiAgICBnbC51bmlmb3JtMWkoZGF0YS51bmlmb3JtLCBkYXRhLnRleHR1cmVVbml0Tm8pO1xuICAgIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmViaW5kRmJvVGV4dHVyZXMoZ2wsIHVuaWZvcm1zKSB7XG4gICAgbGV0IGZib1VuaWZvcm1zID0gT2JqZWN0LmtleXModW5pZm9ybXMpLnJlZHVjZSgoYSwgdW5pZm9ybU5hbWUpID0+IChcbiAgICAgICAgdW5pZm9ybU5hbWUuc3RhcnRzV2l0aCgndV9mYm8nKVxuICAgICAgICA/IFsuLi5hLCB1bmlmb3Jtc1t1bmlmb3JtTmFtZV1dXG4gICAgICAgIDogYVxuICAgICksIFtdKTtcblxuICAgIGZib1VuaWZvcm1zLmZvckVhY2godW5pZm9ybSA9PiB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke3VuaWZvcm0udGV4dHVyZVVuaXRObyB9YF0pO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB1bmlmb3JtLnRleHR1cmUyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0udW5pZm9ybSwgdW5pZm9ybS50ZXh0dXJlVW5pdE5vKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRleHR1cmUoZ2wsIGRhdGEpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsW2BURVhUVVJFJHtkYXRhLnRleHR1cmVVbml0Tm99YF0pO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGRhdGEudGV4dHVyZSk7XG5cbiAgICBsZXQgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBOyAvL2RhdGEuaW50ZXJuYWxGb3JtYXQgfHzCoGdsLlJHQkE7XG4gICAgbGV0IHNyY0Zvcm1hdCA9IGdsLlJHQkE7IC8vZGF0YS5zcmNGb3JtYXQgfHzCoGdsLlJHQkE7XG5cbiAgICBpZih0eXBlb2YgZGF0YS5zaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBkYXRhLnNpemVbMF0sIGRhdGEuc2l6ZVsxXSwgMCwgc3JjRm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBzcmNGb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIHNyY0Zvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgZGF0YS52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIF9pbWFnZURpbWVuc2lvbkFyZVBvd2VyT2YyKGltYWdlKSB7XG4gIHJldHVybiAoaW1hZ2UubmF0dXJhbFdpZHRoICYgKGltYWdlLm5hdHVyYWxXaWR0aCAtIDEpKSA9PSAwICYmIChpbWFnZS5uYXR1cmFsSGVpZ2h0ICYgKGltYWdlLm5hdHVyYWxIZWlnaHQgLSAxKSkgPT0gMDtcbn1cbiIsImltcG9ydCB7aW5pdFRleHR1cmUsIGluaXRGYm9UZXh0dXJlLCBiaW5kRmJvVGV4dHVyZSwgdXBkYXRlVGV4dHVyZSwgbG9hZFRleHR1cmVEYXRhLCByZWJpbmRGYm9UZXh0dXJlc30gZnJvbSAnLi90ZXh0dXJlLXV0aWxzJztcbmltcG9ydCBpdGVyYXRlT2JqZWN0IGZyb20gJy4uL3V0aWxzL2l0ZXJhdGUtb2JqZWN0JztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRVbmlmb3JtcyhnbCwgcHJvZ3JhbSwgdW5pZm9ybURhdGEsIHNoYWRlck5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGxldCBbdW5pZm9ybU5hbWUsIGRhdGFdIG9mIGl0ZXJhdGVPYmplY3QodW5pZm9ybURhdGEpKSB7XG4gICAgICAgIGxldCB1bmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5ldyBTdHJpbmcodW5pZm9ybU5hbWUpKTtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYGhhY2tHbDogJHtzaGFkZXJOYW1lfSBzaGFkZXIgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgYGZhaWxlZCB0byBnZXQgdGhlIHN0b3JhZ2UgbG9jYXRpb24gb2YgXCIke3VuaWZvcm1OYW1lfVwiIC0gaWdub3JpbmcgdmFyaWFibGUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdQZXJoYXBzIHlvdSBmb3Jnb3QgdG8gdXNlIGl0IGluIHlvdXIgc2hhZGVyPycpO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBpbml0IHVuaWZvcm0sIGJ1dCBzdGlsbCBpbml0IHRleHR1cmUgdW5pdCBmb3IgdGhlIGZibyByZW5kZXJpbmdcbiAgICAgICAgICAgIGlmKGRhdGEudHlwZSAhPSAnZmJvX3QnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXBkYXRlZERhdGEgPSB7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgdW5pZm9ybVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGF3YWl0IG5lZWRlZCBmb3IgdGV4dHVyZSBpbWFnZSBkYXRhIGxvYWRpbmdcbiAgICAgICAgdXBkYXRlZERhdGEgPSBhd2FpdCBzZXRVbmlmb3JtVmFsdWUoZ2wsIHVwZGF0ZWREYXRhKTtcbiAgICAgICAgcmVzdWx0W3VuaWZvcm1OYW1lXSA9IHVwZGF0ZWREYXRhO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVVbmlmb3JtcyhnbCwgdW5pZm9ybXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgW2tleSwgZGF0YV0gb2YgaXRlcmF0ZU9iamVjdCh1bmlmb3JtcykpIHtcbiAgICAgICAgbGV0IHVuaWZvcm0gPSByZXN1bHRba2V5XSA9IHsuLi5kYXRhfTtcbiAgICAgICAgaWYodHlwZW9mIHVuaWZvcm0udXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB1bmlmb3JtLnZhbHVlID0gdW5pZm9ybS51cGRhdGUodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICBzZXRVbmlmb3JtVmFsdWUoZ2wsIHVuaWZvcm0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFVuaWZvcm1WYWx1ZShnbCwgZGF0YSwgdXBkYXRpbmcgPSBmYWxzZSkge1xuICAgIHN3aXRjaChkYXRhLnR5cGUpIHtcbiAgICAgICAgLy8gdGV4dHVyZSBzYW1wbGVyXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgaWYoIXVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IGltYWdlRGF0YSA9IHR5cGVvZiBkYXRhLnVybCAhPT0gJ3VuZGVmaW5lZCcgPyBhd2FpdCBsb2FkVGV4dHVyZURhdGEoZGF0YSkgOiBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBpbml0VGV4dHVyZShnbCwgZGF0YSwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih1cGRhdGluZyAmJiBkYXRhLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVGV4dHVyZShnbCwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGZibyB0ZXh0dXJlIHNhbXBsZXJcbiAgICAgICAgY2FzZSAnZmJvX3QnOlxuICAgICAgICAgICAgaWYoIXVwZGF0aW5nICYmICFkYXRhLnRleHR1cmVVbml0Tm8pIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gaW5pdEZib1RleHR1cmUoZ2wsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmluZEZib1RleHR1cmUoZ2wsIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoZGF0YS51bmlmb3JtLCBkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGZsb2F0XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKGRhdGEudW5pZm9ybSwgZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbG9hdCB2ZWMyXG4gICAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGRhdGEudW5pZm9ybSwgZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbG9hdCB2ZWMzXG4gICAgICAgIGNhc2UgJzNmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KGRhdGEudW5pZm9ybSwgZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbG9hdCB2ZWM0XG4gICAgICAgIGNhc2UgJzRmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGRhdGEudW5pZm9ybSwgZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgYDogJHtkYXRhLnR5cGV9IHVuaWZvcm0gbm90IHlldCBpbXBsZW1lbnRlZCFgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG59XG4iLCIvLyByZXF1aXJlKCdiYWJlbC1wb2x5ZmlsbCcpO1xuaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5pbXBvcnQgd2ViR2xVdGlscyBmcm9tICcuL2xpYi93ZWJnbC11dGlscyc7XG5pbXBvcnQgaW5pdFBpeGVsVG95IGZyb20gJy4vZ2wvaW5pdC1waXhlbC10b3knO1xuaW1wb3J0IHZhbGlkYXRlT3B0aW9ucyBmcm9tICcuL2luaXQvb3B0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhY2tHbChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZighb3B0aW9ucy5pc1ZhbGlkKSB7XG4gICAgICAgIHRocm93IGBoYWNrLkdsOiAke29wdGlvbnMuZXJyb3JzfWA7XG4gICAgfVxuXG4gICAgX3NldHVwQ2FudmFzUmVzb2x1dGlvbihvcHRpb25zKTtcbiAgICBsZXQgZ2wgPSBfZ2V0V2ViR2xDb250ZXh0KG9wdGlvbnMuY2FudmFzKTtcblxuICAgIC8vIHZhciBmbG9hdF90ZXh0dXJlX2V4dCA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkZsb2F0IHRleHR1cmUgZXh0ZW5zaW9uOiBcIiArIGZsb2F0X3RleHR1cmVfZXh0KTtcblxuICAgIC8vIHNwZWNpZnkgdGhlIGNvbG9yIGZvciBjbGVhcmluZyBjYW52YXNcbiAgICBnbC5jbGVhckNvbG9yKC4uLm9wdGlvbnMuY2xlYXJDb2xvcik7XG5cbiAgICBpbml0UGl4ZWxUb3koZ2wsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0V2ViR2xDb250ZXh0KGNhbnZhcywgZGVidWcgPSBmYWxzZSkge1xuICAgIGxldCBnbCA9IHdlYkdsVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgICAgdGhyb3cgJ2hhY2suR2w6IGZhaWxlZCB0byBnZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB3ZWJHbCc7XG4gICAgfVxuXG4gICAgaWYoZGVidWcpIHtcbiAgICAgICAgZ2wgPSB3ZWJHbFV0aWxzLm1ha2VEZWJ1Z0NvbnRleHQoZ2wpO1xuICAgIH1cblxuICAgIHJldHVybiBnbDtcbn1cblxuZnVuY3Rpb24gX3NldHVwQ2FudmFzUmVzb2x1dGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5jYW52YXMud2lkdGggPSBvcHRpb25zLnJlc29sdXRpb24ud2lkdGg7XG4gICAgb3B0aW9ucy5jYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodDtcbn1cbiIsIi8vIHdvdywgeWVhaCwgdGhpcyBuZWVkcyB3b3JrIC0gdGhlIGJvcmluZyBwYXJ0XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IHZhbGlkYXRlZE9wdGlvbnMgPSB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIGVycm9yczogJycsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FudmFzID09PSAndW5kZWZpbmVkJyB8fCAhb3B0aW9ucy5jYW52YXMpIHtcbiAgICAgICAgdmFsaWRhdGVkT3B0aW9ucy5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHZhbGlkYXRlZE9wdGlvbnMuZXJyb3JzID0gXCJcXG5ObyBjYW52YXMgZWxlbWVudCBzdXBwbGllZCB3aGVuIGNhbGxpbmcgaGFja0dsKClcIjtcbiAgICB9XG5cbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jbGVhckNvbG9yID09PSAndW5kZWZpbmVkJyB8fCAhb3B0aW9ucy5jbGVhckNvbG9yKSB7XG4gICAgICAgIHZhbGlkYXRlZE9wdGlvbnMuY2xlYXJDb2xvciA9IFswLjAsIDAuMCwgMC4wLCAxLjBdO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnJlc29sdXRpb24gPT09ICd1bmRlZmluZWQnIHx8ICFvcHRpb25zLnJlc29sdXRpb24ud2lkdGggfHzCoCFvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0KSB7XG4gICAgICAgIHZhbGlkYXRlZE9wdGlvbnMucmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5mZWVkYmFja0ZibyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMuZmVlZGJhY2tGYm8ucmVzb2x1dGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5mZWVkYmFja0Ziby5yZXNvbHV0aW9uLndpZHRoIHx8wqAhb3B0aW9ucy5mZWVkYmFja0Ziby5yZXNvbHV0aW9uLmhlaWdodCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnMuZmVlZGJhY2tGYm8ucmVzb2x1dGlvbiA9IHZhbGlkYXRlZE9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnVuaWZvcm1zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWxpZGF0ZWRPcHRpb25zLnVuaWZvcm1zID0ge307XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIG9wdGlvbnMub25SZW5kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbGlkYXRlZE9wdGlvbnMub25SZW5kZXIgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkT3B0aW9ucztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxMCwgR29vZ2xlIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbiAqIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiAqIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgZnVuY3Rpb25zIGV2ZXJ5IHdlYmdsIHByb2dyYW0gd2lsbCBuZWVkXG4gKiBhIHZlcnNpb24gb2Ygb25lIHdheSBvciBhbm90aGVyLlxuICpcbiAqIEluc3RlYWQgb2Ygc2V0dGluZyB1cCBhIGNvbnRleHQgbWFudWFsbHkgaXQgaXMgcmVjb21tZW5kZWQgdG9cbiAqIHVzZS4gVGhpcyB3aWxsIGNoZWNrIGZvciBzdWNjZXNzIG9yIGZhaWx1cmUuIE9uIGZhaWx1cmUgaXRcbiAqIHdpbGwgYXR0ZW1wdCB0byBwcmVzZW50IGFuIGFwcHJvcmlhdGUgbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICBnbCA9IFdlYkdMVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpO1xuICpcbiAqIEZvciBhbmltYXRlZCBXZWJHTCBhcHBzIHVzZSBvZiBzZXRUaW1lb3V0IG9yIHNldEludGVydmFsIGFyZVxuICogZGlzY291cmFnZWQuIEl0IGlzIHJlY29tbWVuZGVkIHlvdSBzdHJ1Y3R1cmUgeW91ciByZW5kZXJpbmdcbiAqIGxvb3AgbGlrZSB0aGlzLlxuICpcbiAqICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAqICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIsIGNhbnZhcyk7XG4gKlxuICogICAgICAgICAvLyBkbyByZW5kZXJpbmdcbiAqICAgICAgICAgLi4uXG4gKiAgICAgICB9XG4gKiAgICAgICByZW5kZXIoKTtcbiAqXG4gKiBUaGlzIHdpbGwgY2FsbCB5b3VyIHJlbmRlcmluZyBmdW5jdGlvbiB1cCB0byB0aGUgcmVmcmVzaCByYXRlXG4gKiBvZiB5b3VyIGRpc3BsYXkgYnV0IHdpbGwgc3RvcCByZW5kZXJpbmcgaWYgeW91ciBhcHAgaXMgbm90XG4gKiB2aXNpYmxlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBmdW5jdGlvbigpIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaW4gYSBjcm9zcyBicm93c2VyXG4gICAgICogd2F5LlxuICAgICAqL1xuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrLCAvKiBET01FbGVtZW50IEVsZW1lbnQgKi8gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMC82MCk7XG4gICAgICAgICAgICAgICB9O1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvKiogKiBFUlJBVEE6ICdjYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIHJlbmFtZWQgdG8gJ2NhbmNlbEFuaW1hdGlvbkZyYW1lJyB0byByZWZsZWN0IGFuIHVwZGF0ZSB0byB0aGUgVzNDIEFuaW1hdGlvbi1UaW1pbmcgU3BlYy5cbiAgICAgKlxuICAgICAqIENhbmNlbHMgYW4gYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QuXG4gICAgICogQ2hlY2tzIGZvciBjcm9zcy1icm93c2VyIHN1cHBvcnQsIGZhbGxzIGJhY2sgdG8gY2xlYXJUaW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgQW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QuICovXG4gICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICh3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBIVExNIGZvciBhIGZhaWx1cmUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYW52YXNDb250YWluZXJJZCBpZCBvZiBjb250YWluZXIgb2YgdGhcbiAgICAgKiAgICAgICAgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGh0bWwuXG4gICAgICovXG4gICAgdmFyIG1ha2VGYWlsSFRNTCA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgcmV0dXJuICcnICtcbiAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwibWFyZ2luOiBhdXRvOyB3aWR0aDo1MDBweDt6LWluZGV4OjEwMDAwO21hcmdpbi10b3A6MjBlbTt0ZXh0LWFsaWduOmNlbnRlcjtcIj4nICsgbXNnICsgJzwvZGl2Pic7XG4gICAgICByZXR1cm4gJycgK1xuICAgICAgICAnPHRhYmxlIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogIzhDRTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcIj48dHI+JyArXG4gICAgICAgICc8dGQgYWxpZ249XCJjZW50ZXJcIj4nICtcbiAgICAgICAgJzxkaXYgc3R5bGU9XCJkaXNwbGF5OiB0YWJsZS1jZWxsOyB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1wiPicgK1xuICAgICAgICAnPGRpdiBzdHlsZT1cIlwiPicgKyBtc2cgKyAnPC9kaXY+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzwvdGQ+PC90cj48L3RhYmxlPic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lc2FzZ2UgZm9yIGdldHRpbmcgYSB3ZWJnbCBicm93c2VyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgR0VUX0FfV0VCR0xfQlJPV1NFUiA9ICcnICtcbiAgICAgICdUaGlzIHBhZ2UgcmVxdWlyZXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgV2ViR0wuPGJyLz4nICtcbiAgICAgICc8YSBocmVmPVwiaHR0cDovL2dldC53ZWJnbC5vcmdcIj5DbGljayBoZXJlIHRvIHVwZ3JhZGUgeW91ciBicm93c2VyLjwvYT4nO1xuXG4gICAgLyoqXG4gICAgICogTWVzYXNnZSBmb3IgbmVlZCBiZXR0ZXIgaGFyZHdhcmVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHZhciBPVEhFUl9QUk9CTEVNID0gJycgK1xuICAgICAgXCJJdCBkb2Vzbid0IGFwcGVhciB5b3VyIGNvbXB1dGVyIGNhbiBzdXBwb3J0IFdlYkdMLjxici8+XCIgK1xuICAgICAgJzxhIGhyZWY9XCJodHRwOi8vZ2V0LndlYmdsLm9yZ1wiPkNsaWNrIGhlcmUgZm9yIG1vcmUgaW5mb3JtYXRpb24uPC9hPic7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC4gSWYgY3JlYXRpb24gZmFpbHMgaXQgd2lsbFxuICAgICAqIGNoYW5nZSB0aGUgY29udGVudHMgb2YgdGhlIGNvbnRhaW5lciBvZiB0aGUgPGNhbnZhcz5cbiAgICAgKiB0YWcgdG8gYW4gZXJyb3IgbWVzc2FnZSB3aXRoIHRoZSBjb3JyZWN0IGxpbmtzIGZvciBXZWJHTC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhcy4gVGhlIGNhbnZhcyBlbGVtZW50IHRvIGNyZWF0ZSBhXG4gICAgICogICAgIGNvbnRleHQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge1dlYkdMQ29udGV4dENyZWF0aW9uQXR0aXJidXRlc30gb3B0X2F0dHJpYnMgQW55XG4gICAgICogICAgIGNyZWF0aW9uIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gcGFzcyBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uOihtc2cpfSBvcHRfb25FcnJvciBBbiBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogICAgIGlmIHRoZXJlIGlzIGFuIGVycm9yIGR1cmluZyBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gICAgICovXG4gICAgdmFyIHNldHVwV2ViR0wgPSBmdW5jdGlvbihjYW52YXMsIG9wdF9hdHRyaWJzLCBvcHRfb25FcnJvcikge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlQ3JlYXRpb25FcnJvcihtc2cpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgICAgICAvL3ZhciBjb250YWluZXIgPSBjYW52YXMucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgIHZhciBzdHIgPSB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ID9cbiAgICAgICAgICAgICAgIE9USEVSX1BST0JMRU0gOlxuICAgICAgICAgICAgICAgR0VUX0FfV0VCR0xfQlJPV1NFUjtcbiAgICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICBzdHIgKz0gXCI8YnIvPjxici8+U3RhdHVzOiBcIiArIG1zZztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IG1ha2VGYWlsSFRNTChzdHIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBvcHRfb25FcnJvciA9IG9wdF9vbkVycm9yIHx8IGhhbmRsZUNyZWF0aW9uRXJyb3I7XG5cbiAgICAgIGlmIChjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3JcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgb3B0X29uRXJyb3IoZXZlbnQuc3RhdHVzTWVzc2FnZSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGV4dCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICBvcHRfb25FcnJvcihcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRfb25FcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHshQ2FudmFzfSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0IGNvbnRleHRcbiAgICAgKiAgICAgZnJvbS4gSWYgb25lIGlzIG5vdCBwYXNzZWQgaW4gb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHshV2ViR0xDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGUzRENvbnRleHQgPSBmdW5jdGlvbihjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBcIndlYmtpdC0zZFwiLCBcIm1vei13ZWJnbFwiXTtcbiAgICAgIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuYW1lcy5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaWldLCBvcHRfYXR0cmlicyk7XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZTNEQ29udGV4dDogY3JlYXRlM0RDb250ZXh0LFxuICAgICAgc2V0dXBXZWJHTDogc2V0dXBXZWJHTFxuICAgIH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdV9hdWRpb19kYXRhO1xcblxcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1Nzk5Mjg2XFxuZmxvYXQgX2hhY2tnbF90b0xvZyhmbG9hdCB2YWx1ZSwgZmxvYXQgbWluLCBmbG9hdCBtYXgpe1xcbiAgICBmbG9hdCBleHAgPSAodmFsdWUtbWluKSAvIChtYXgtbWluKTtcXG4gICAgcmV0dXJuIG1pbiAqIHBvdyhtYXgvbWluLCBleHApO1xcbn1cXG5cXG4vKlxcbiAqIEZyZXEgZGF0YSBpcyBzdG9yZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMvcmdiYS4gU2luY2Ugd2ViR2wgMSBkb2Vzbid0IGhhdmUgdGV4ZWxGZXRjaCB3ZSBoYXZlIHRvXFxuICogYWNjZXNzIHRoZSBkYXRhIHdpdGggdXYgY29vcmRpbmF0ZXMgdXNpbmcgdGV4dHVyZTJELlxcbiAqXFxuICogRXhhbXBsZTpcXG4gKiBBc3N1bWUgYW4gZmZ0IHNpemUgb2YgNTEyLCB3aGljaCBtZWFucyBhIGJpbiBjb3VudCBvZiAyNTYgZnJlcSBkYXRhIHZhbHVlcy5cXG4gKiBUbyBhY2Nlc3MgZnJlcSBkYXRhIGF0LCBmb3IgZXhhbXBsZSwgaW5kZXggMTI4IGluIHRoZSBvcmlnaW5hbCBhcnJheSByZXR1cm5lZCBmcm9tIHRoZSB3ZWIgYXVkaW8gYXBpLCBkbzpcXG4gKiBfaGFja2dsX2dldEZyZXFEYXRhKDEyOC4wLzI1Ni4wKTtcXG4gKi9cXG5cXG5mbG9hdCBfaGFja2dsX2dldEZyZXFEYXRhKGZsb2F0IGluZGV4KSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodV9hdWRpb19kYXRhLCB2ZWMyKGluZGV4LCAwLjUpKS5yO1xcbn1cXG5cXG5mbG9hdCBoYWNrZ2xfZ2V0QXVkaW9GcmVxRGF0YShmbG9hdCBpbmRleCwgZmxvYXQgbWluQ3JvcCwgZmxvYXQgbWF4Q3JvcCkge1xcbiAgICAvLyBjcm9wIGJvdHRvbSBhbmQgdG9wIG9mIHJhbmdlXFxuICAgIGZsb2F0IHhDb29yZCA9IG1peChtaW5Dcm9wLCBtYXhDcm9wLCBpbmRleCk7XFxuXFxuICAgIC8vIGdldCBmcmVxIGZvciBjdXJyZW50IGluZGV4XFxuICAgIGZsb2F0IGZmdCA9IF9oYWNrZ2xfZ2V0RnJlcURhdGEoeENvb3JkKTtcXG4gICAgcmV0dXJuIGZmdDtcXG59XFxuXFxuZmxvYXQgaGFja2dsX2dldEF1ZGlvRnJlcURhdGEoZmxvYXQgaW5kZXgpIHtcXG4gICAgcmV0dXJuIGhhY2tnbF9nZXRBdWRpb0ZyZXFEYXRhKGluZGV4LCAwLjMsIDAuNyk7XFxufVxcblxcbmZsb2F0IGhhY2tnbF9nZXRMb2dBdWRpb0ZyZXFEYXRhKGZsb2F0IGluZGV4LCBmbG9hdCBtaW5Dcm9wLCBmbG9hdCBtYXhDcm9wKSB7XFxuICAgIC8vY3JvcCBib3R0b20gYW5kIHRvcCBvZiByYW5nZVxcbiAgICBmbG9hdCB4Q29vcmQgPSBtaXgobWluQ3JvcCwgbWF4Q3JvcCwgaW5kZXgpO1xcbiAgICAvL2xvZ2FyaXRobWljIHNhbXBsaW5nXFxuICAgIGZsb2F0IHhQb3MgPSBfaGFja2dsX3RvTG9nKHhDb29yZCwgMC4wMSwgMS4wKTtcXG5cXG4gICAgLy8gZ2V0IGZyZXEgZm9yIGN1cnJlbnQgaW5kZXhcXG4gICAgZmxvYXQgZmZ0ID0gX2hhY2tnbF9nZXRGcmVxRGF0YSh4UG9zKTtcXG4gICAgcmV0dXJuIGZmdDtcXG59XFxuXFxuZmxvYXQgaGFja2dsX2dldExvZ0F1ZGlvRnJlcURhdGEoZmxvYXQgaW5kZXgpIHtcXG4gICAgcmV0dXJuIGhhY2tnbF9nZXRMb2dBdWRpb0ZyZXFEYXRhKGluZGV4LCAwLjMsIDAuNyk7XFxufVxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHVfY2FtZXJhO1xcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHVfZmJvMDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ZibzE7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9mYm8yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZmJvMztcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ZibzQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9mYm81O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZmJvNjtcXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJ2b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTtcXG59XFxuXCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2lmZGVmIEdMX0VTXFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XFxudW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxudW5pZm9ybSBpbnQgdV9mcmFtZV9jb3VudDtcXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBhX3Bvc2l0aW9uO1xcbn1cXG5cIjtcbiIsImNvbnN0IGNvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbnZhciBhbmFseXNlciA9IG51bGwsIHNvdXJjZSA9IG51bGw7XG5cbmxldCBhdWRpb1VuaWZvcm1CYXNlID0ge1xuICAgIHR5cGU6ICd0JyxcbiAgICBuZWVkc1VwZGF0ZTogdHJ1ZSxcbiAgICB1cGRhdGU6ICgpID0+IGdldEZyZXF1ZW5jeURhdGEoKSxcbiAgICB3cmFwUzogJ2NsYW1wJyxcbiAgICB3cmFwVDogJ2NsYW1wJ1xufVxuXG5sZXQgYXVkaW9Vbmlmb3JtID0gbnVsbDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRBdWRpb0FuYWx5c2VyVW5pZm9ybShnbCwgb3B0aW9ucykge1xuICAgIGlmKGF1ZGlvVW5pZm9ybSkge1xuICAgICAgICByZXR1cm4gYXVkaW9Vbmlmb3JtO1xuICAgIH1cblxuICAgIGNvbnN0IGFuYWx5c2VyT3B0aW9ucyA9IG9wdGlvbnMuYXVkaW9BbmFseXNlcjtcblxuICAgIGFuYWx5c2VyID0gY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgIGFuYWx5c2VyLmZmdFNpemUgPSBhbmFseXNlck9wdGlvbnMuZmZ0U2l6ZSB8fCAxMDI0OyAvLyAxMDI0IC8gMiA9IDUxMiBkYXRhIHBvaW50cyBwZXIgc2FtcGxlIG9mIHNvdW5kXG4gICAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gYW5hbHlzZXJPcHRpb25zLnNtb290aGluZyB8fCAwLjU7IC8vMC4yO1xuXG4gICAgcmV0dXJuIGZldGNoKGFuYWx5c2VyT3B0aW9ucy51cmwpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpXG4gICAgICAgIC50aGVuKGFycmF5QnVmZmVyID0+IGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGFycmF5QnVmZmVyKSlcbiAgICAgICAgLnRoZW4oYXVkaW9CdWZmZXIgPT4ge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgICAgICAgIGFuYWx5c2VyLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBzb3VyY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgIHNvdXJjZS5sb29wID0gdHJ1ZTtcblxuICAgICAgICAgICAgYXVkaW9Vbmlmb3JtID0ge1xuICAgICAgICAgICAgICAgIC4uLmF1ZGlvVW5pZm9ybUJhc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldEZyZXF1ZW5jeURhdGEoKSxcbiAgICAgICAgICAgICAgICBzaXplOiBbYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQsIDFdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvVW5pZm9ybTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBoYWNrLmdsOiBmYWlsZWQgdG8gZmV0Y2ggYXVkaW8gZGF0YTogYCk7XG4gICAgICAgICAgICBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJlcXVlbmN5RGF0YSgpIHtcbiAgICBjb25zdCBzaXplID0gYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XG5cbiAgICBsZXQgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IHNoYWRlckRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogNCk7XG5cbiAgICAvLyBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoZGF0YUFycmF5KTtcbiAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhQXJyYXkpO1xuXG4gICAgZGF0YUFycmF5LmZvckVhY2goKHZhbCwgaSkgPT4ge1xuICAgICAgICBzaGFkZXJEYXRhLmZpbGwodmFsLCBpICogNCwgKGkgKyAxKSAqIDQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNoYWRlckRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleGVjdXRlQ2FsbGJhY2tPckFycmF5KGNhbGxiYWNrKSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShjYWxsYmFjaykpIHtcbiAgICAgICAgY2FsbGJhY2suZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICB9IGVsc2UgaWYodHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdoYWNrR2w6IGlsbGVnYWwgY2FsbGJhY2snO1xuICAgIH1cbn1cbiIsImxldCBmcmFtZUNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lQ291bnQoKSB7XG4gICAgcmV0dXJuIGZyYW1lQ291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGcmFtZUNvdW50KCkge1xuICAgIHJldHVybiArK2ZyYW1lQ291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGcmFtZUNvdW50KHZhbCkge1xuICAgIGZyYW1lQ291bnQgPSB2YWw7XG4gICAgcmV0dXJuIHZhbDtcbn1cbiIsImxldCBoYW5kbGVyID0gbnVsbDtcbmxldCBwb3NpdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oY2FudmFzKSB7XG4gICAgaWYoIWhhbmRsZXIpIHtcbiAgICAgICAgY2FudmFzID0gdHlwZW9mIGNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF0gOiBjYW52YXM7XG4gICAgICAgIGhhbmRsZXIgPSBjYW52YXMub25tb3VzZW1vdmUgPSBlID0+IHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IChlLnBhZ2VYIC0gY2FudmFzLm9mZnNldExlZnQpIC8gY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgIHk6IChlLnBhZ2VZIC0gY2FudmFzLm9mZnNldFRvcCkgLyBjYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3Bvc2l0aW9uLngsIHBvc2l0aW9uLnldO1xufVxuIiwiLy8gaGVscGVyIGdlbmVyYXRvciB0byBpdGVyYXRlIGJ5IFtrZXksIHZhbHVlXSBvdmVyIG9iamVjdHNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiBpdGVyYXRlT2JqZWN0KG9iaikge1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIHlpZWxkIFtrZXksIG9ialtrZXldXTtcbiAgICB9XG59XG4iLCJsZXQgY29udGV4dCA9IG51bGwsIGNhbnZhcyA9IG51bGwsIHN0cmVhbWluZyA9IGZhbHNlO1xuXG5sZXQgY2FtZXJhVW5pZm9ybUJhc2UgPSB7XG4gICAgdHlwZTogJ3QnLFxuICAgIG5lZWRzVXBkYXRlOiB0cnVlLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyYXBTOiAnY2xhbXAnLFxuICAgIHdyYXBUOiAnY2xhbXAnXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhVW5pZm9ybSgpIHtcbiAgICBsZXQgdmlkZW87XG5cbiAgICB0cnkge1xuICAgICAgICB2aWRlbyA9IGF3YWl0IF9pbml0Q2FtZXJhKCk7XG4gICAgfSBjYXRjaChlcnJvcinCoHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jYW1lcmFVbmlmb3JtQmFzZSxcbiAgICAgICAgdmFsdWU6IHZpZGVvLFxuICAgICAgICB1cGRhdGU6ICgpID0+IHZpZGVvXG4gICAgfVxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIF9pbml0Q2FtZXJhKCkge1xuICAgIGlmKHN0cmVhbWluZykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZGVvJyk7XG4gICAgfVxuXG4gICAgbGV0IHZpZGVvID0gX2luamVjdFZpZGVvRWxlbWVudCgpO1xuICAgIGxldCBzdHJlYW07XG5cbiAgICB0cnkge1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCBfZ2V0Q2FtZXJhU3RyZWFtKCk7XG4gICAgfSBjYXRjaChlcnJvcinCoHtcbiAgICAgICAgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICB0aHJvdyAnaGFja0dsOiBDb3VsZCBub3QgbG9hZCBjYW1lcmEgc3RyZWFtOic7XG4gICAgfVxuXG4gICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgIHZpZGVvLnBsYXkoKTtcbiAgICBzdHJlYW1pbmcgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIChlKSA9PiByZXNvbHZlKHZpZGVvKSwgZmFsc2UpXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9nZXRDYW1lcmFTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgICAgICBtaW46IDY0MCwgaWRlYWw6IDY0MCwgbWF4OiA2NDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgICAgICBtaW46IDQ4MCwgaWRlYWw6IDQ4MCwgbWF4OiA0ODBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2luamVjdFZpZGVvRWxlbWVudCgpIHtcbiAgICBsZXQgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXG4gICAgdmlkZW8uaWQgPSAndmlkZW8nO1xuICAgIHZpZGVvLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdmlkZW8uaW5uZXJIVE1MID0gJ1ZpZGVvIHN0cmVhbSBub3QgYXZhaWxhYmxlLic7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUodmlkZW8sIGRvY3VtZW50LmJvZHkuY2hpbGROb2Rlc1swXSk7XG5cbiAgICByZXR1cm4gdmlkZW87XG59XG4iXX0="}